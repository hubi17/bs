<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Regex Tutorial - Start and End of String or Line Anchors</TITLE>
<script src="regex.js" type="text/javascript"></script>
<link rel="alternate" type="application/rss+xml" title="Regex Guru" href="http://www.regexguru.com/feed/">
<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="In a regular expression, the caret matches the concept "start of string", while the dollar sign matches "end of string"">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<script type="text/javascript">window.onresize = movecontent;</script>
<DIV id=top><DIV id=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<div id=btntop><table align=center cellspacing=0 cellpadding=0 border=0><tr><td><a href="tutorial.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tutorial</div></a></td><td><a href="tools.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tools&nbsp;&amp;&nbsp;Languages</div></a></td><td><a href="examples.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Examples</div></a></td><td><a href="books.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Books&nbsp;&amp;&nbsp;Reference</div></a></td></tr></table></div>
<DIV id=bodytext>
<script type="text/javascript">movecontent();</script>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/regexbuddyad.png" width=203 height=145 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><B><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>.</B><BR> Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this website, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A></TD> </TR></TABLE>  <H1>Start of String and End of String Anchors</H1> <P>Thus far, I have explained <A HREF="characters.html" TARGET="_top">literal characters</A> and <A HREF="charclass.html" TARGET="_top">character classes</A>. In both cases, putting one in a regex will cause the regex engine to try to match a single character.</P> <P>Anchors are a different breed. They do not match any character at all. Instead, they match a position before, after or between characters. They can be used to "anchor" the regex match at a certain position. The caret <TT CLASS=regex>^</TT> matches the position before the first character in the string. Applying <TT CLASS=regex>^a</TT> to <TT CLASS=string>abc</TT> matches <TT CLASS=match>a</TT>. <TT CLASS=regex>^b</TT> will not match <TT CLASS=string>abc</TT> at all, because the <TT CLASS=regex>b</TT> cannot be matched right after the start of the string, matched by <TT CLASS=regex>^</TT>. See below for the inside view of the regex engine.</P> <P>Similarly, <TT CLASS=regex>$</TT> matches right after the last character in the string. <TT CLASS=regex>c$</TT> matches <TT CLASS=match>c</TT> in <TT CLASS=string>abc</TT>, while <TT CLASS=regex>a$</TT> does not match at all.</P> <script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><H2>Useful Applications</H2> <P>When using regular expressions in a programming language to validate user input, using anchors is very important. If you use the code <TT CLASS=code>if ($input =~ m/\d+/)</TT> in a <A HREF="perl.html" TARGET="_top">Perl</A> script to see if the user entered an integer number, it will accept the input even if the user entered <TT CLASS=string>qsdf4ghjk</TT>, because <TT CLASS=regex>\d+</TT> matches the 4. The correct regex to use is <TT CLASS=regex>^\d+$</TT>. Because "start of string" must be matched before the match of <TT CLASS=regex>\d+</TT>, and "end of string" must be matched right after it, the entire string must consist of <A HREF="charclass.html#shorthand">digits</A> for <TT CLASS=regex>^\d+$</TT> to be able to match.</P> <P>It is easy for the user to accidentally type in a space. When Perl reads from a line from a text file, the line break will also be stored in the variable. So before validating input, it is good practice to trim leading and trailing <A HREF="charclass.html#shorthand">whitespace</A>. <TT CLASS=regex>^\s+</TT> matches leading whitespace and <TT CLASS=regex>\s+$</TT> matches trailing whitespace. In Perl, you could use <TT CLASS=code>$input =~ s/^\s+|\s+$//g</TT>. Handy use of alternation and /g allows us to do this in a single line of code.</P> <A NAME="multi"></A><H2>Using ^ and $ as Start of Line and End of Line Anchors</H2> <P>If you have a string consisting of multiple lines, like <TT CLASS=string>first line\nsecond line</TT> (where \n indicates a line break), it is often desirable to work with lines, rather than the entire string. Therefore, all the regex engines discussed in this tutorial have the option to expand the meaning of both anchors. <TT CLASS=regex>^</TT> can then match at the start of the string (before the <TT CLASS=string>f</TT> in the above string), as well as after each line break (between <TT CLASS=string>\n</TT> and <TT CLASS=string>s</TT>). Likewise, <TT CLASS=regex>$</TT> will still match at the end of the string (after the last <TT CLASS=string>e</TT>), and also before every line break (between <TT CLASS=string>e</TT> and <TT CLASS=string>\n</TT>).</P> <P>In text editors like <A HREF="editpadpro.html" TARGET="_top">EditPad Pro</A> or GNU Emacs, and regex tools like <A HREF="powergrep.html" TARGET="_top">PowerGREP</A>, the caret and dollar always match at the start and end of each line. This makes sense because those applications are designed to work with entire files, rather than short strings.</P> <P>In all programming languages and libraries discussed on this website , except <A HREF="ruby.html" TARGET="_top">Ruby</A>, you have to explicitly activate this extended functionality. It is traditionally called "multi-line mode". In Perl, you do this by adding an m after the regex code, like this: <TT CLASS=code>m/^regex$/m;</TT>. In <A HREF="dotnet.html" TARGET="_top">.NET</A>, the anchors match before and after newlines when you specify <TT CLASS=code>RegexOptions.Multiline</TT>, such as in <TT CLASS=code>Regex.Match("string", "regex", RegexOptions.Multiline)</TT>.</P> <A NAME="az"></A><H2>Permanent Start of String and End of String Anchors</H2> <P><TT CLASS=regex>\A</TT> only ever matches at the start of the string. Likewise, <TT CLASS=regex>\Z</TT> only ever matches at the end of the string. These two tokens never match at line breaks. This is true in all regex flavors discussed in this tutorial, even when you turn on "multiline mode". In EditPad Pro and PowerGREP, where the caret and dollar always match at the start and end of lines, <TT CLASS=regex>\A</TT> and <TT CLASS=regex>\Z</TT> only match at the start and the end of the entire file.</P> <p><A HREF="javascript.html" TARGET="_top">JavaScript</A>, <A HREF="posix.html" TARGET="_top">POSIX</A> and <A HREF="xml.html" TARGET="_top">XML</A> do not support <TT CLASS=regex>\A</TT> and <TT CLASS=regex>\Z</TT>. You're stuck with using the caret and dollar for this purpose.</p> <p>The <A HREF="gnu.html" TARGET="_top">GNU extensions</A> to POSIX regular expressions use <tt class=regex>\`</tt> (backtick) to match the start of the string, and <tt class=regex>\'</tt> (single quote) to match the end of the string.</p> <H2>Zero-Length Matches</H2> <P>We saw that the anchors match at a position, rather than matching a character. This means that when a regex only consists of one or more anchors, it can result in a zero-length match. Depending on the situation, this can be very useful or undesirable. Using <TT CLASS=regex>^\d*$</TT> to test if the user entered a number (notice the use of the <A HREF="repeat.html" TARGET="_top">star</A> instead of the <A HREF="repeat.html" TARGET="_top">plus</A>), would cause the script to accept an empty string as a valid input. <a href="anchors.html#inside2">See below</a>.</P> <P>However, matching only a position can be very useful. In email, for example, it is common to prepend a "greater than" symbol and a space to each line of the quoted message. In <A HREF="dotnet.html" TARGET="_top">VB.NET</A>, we can easily do this with <TT CLASS=code>Dim Quoted as String = Regex.Replace(Original, "^", "> ", RegexOptions.Multiline)</TT>. We are using multi-line mode, so the regex <TT CLASS=regex>^</TT> matches at the start of the quoted message, and after each newline. The Regex.Replace method will remove the regex match from the string, and insert the replacement string (greater than symbol and a space). Since the match does not include any characters, nothing is deleted. However, the match does include a starting position, and the replacement string is inserted there, just like we want it.</P> <A NAME="realend"></A><H2>Strings Ending with a Line Break</H2> <P>Even though <TT CLASS=regex>\Z</TT> and <TT CLASS=regex>$</TT> only match at the end of the string (when the option for the caret and dollar to match at embedded line breaks is off), there is one exception. If the string ends with a line break, then <TT CLASS=regex>\Z</TT> and <TT CLASS=regex>$</TT> will match at the position before that line break, rather than at the very end of the string. This "enhancement" was introduced by Perl, and is copied by many regex flavors, including <A HREF="java.html" TARGET="_top">Java</A>, <A HREF="dotnet.html" TARGET="_top">.NET</A> and <A HREF="pcre.html" TARGET="_top">PCRE</A>. In Perl, when reading a line from a file, the resulting string will end with a line break. Reading a line from a file with the text "joe" results in the string <TT CLASS=string>joe\n</TT>. When applied to this string, both <TT CLASS=regex>^[a-z]+$</TT> and <TT CLASS=regex>\A[a-z]+\Z</TT> will match <TT CLASS=match>joe</TT>.</P> <P>If you only want a match at the absolute very end of the string, use <TT CLASS=regex>\z</TT> (lower case z instead of upper case Z). <TT CLASS=regex>\A[a-z]+\z</TT> does not match <TT CLASS=string>joe\n</TT>. <TT CLASS=regex>\z</TT> matches after the line break, which is not matched by the <A HREF="charclass.html" TARGET="_top">character class</A>.</P> <H2>Looking Inside the Regex Engine</H2> <P>Let's see what happens when we try to match <TT CLASS=regex>^4$</TT> to <TT CLASS=string>749\n486\n4</TT> (where \n represents a newline character) in multi-line mode. As usual, the regex engine starts at the first character: <TT CLASS=string>7</TT>. The first token in the regular expression is <TT CLASS=regex>^</TT>. Since this token is a zero-width token, the engine does not try to match it with the character, but rather with the position before the character that the regex engine has reached so far. <TT CLASS=regex>^</TT> indeed matches the position before <TT CLASS=string>7</TT>. The engine then advances to the next regex token: <TT CLASS=regex>4</TT>. Since the previous token was zero-width, the regex engine does <EM>not</EM> advance to the next character in the string. It remains at <TT CLASS=string>7</TT>. <TT CLASS=regex>4</TT> is a literal character, which does not match <TT CLASS=string>7</TT>. There are no other permutations of the regex, so the engine starts again with the first regex token, at the next character: <TT CLASS=string>4</TT>. This time, <TT CLASS=regex>^</TT> cannot match at the position before the 4. This position is preceded by a character, and that character is not a newline. The engine continues at <TT CLASS=string>9</TT>, and fails again. The next attempt, at <TT CLASS=string>\n</TT>, also fails. Again, the position before <TT CLASS=string>\n</TT> is preceded by a character, <TT CLASS=string>9</TT>, and that character is not a newline.</P> <P>Then, the regex engine arrives at the second <TT CLASS=string>4</TT> in the string. The <TT CLASS=regex>^</TT> can match at the position before the <TT CLASS=string>4</TT>, because it is preceded by a newline character. Again, the regex engine advances to the next regex token, <TT CLASS=regex>4</TT>, but does not advance the character position in the string. <TT CLASS=regex>4</TT> matches <TT CLASS=match>4</TT>, and the engine advances both the regex token and the string character. Now the engine attempts to match <TT CLASS=regex>$</TT> at the position before (indeed: before) the <TT CLASS=string>8</TT>. The dollar cannot match here, because this position is followed by a character, and that character is not a newline.</P> <P>Yet again, the engine must try to match the first token again. Previously, it was successfully matched at the second <TT CLASS=string>4</TT>, so the engine continues at the next character, <TT CLASS=string>8</TT>, where the caret does not match. Same at the six and the newline.</P> <P>Finally, the regex engine tries to match the first token at the third <TT CLASS=string>4</TT> in the string. With success. After that, the engine successfully matches <TT CLASS=regex>4</TT> with <TT CLASS=match>4</TT>. The current regex token is advanced to <TT CLASS=regex>$</TT>, and the current character is advanced to the very last position in the string: the void after the string. No regex token that needs a character to match can match here. Not even a <A HREF="charclass.html#negated">negated character class</A>. However, we are trying to match a dollar sign, and the mighty dollar is a strange beast. It is zero-width, so it will try to match the position before the current character. It does not matter that this "character" is the void after the string. In fact, the dollar will check the current character. It must be either a newline, or the void after the string, for <TT CLASS=regex>$</TT> to match the position before the current character. Since that is the case after the example, the dollar matches successfully.</P> <P>Since <TT CLASS=regex>$</TT> was the last token in the regex, the engine has found a successful match: the last <TT CLASS=match>4</TT> in the string.</P> <a name="inside2"></a><H2>Another Inside Look</H2> <P>Earlier I mentioned that <TT CLASS=regex>^\d*$</TT> would successfully match an empty string. Let's see why.</P> <P>There is only one "character" position in an empty string: the void after the string. The first token in the regex is <TT CLASS=regex>^</TT>. It matches the position before the void after the string, because it is preceded by the void before the string. The next token is <TT CLASS=regex>\d*</TT>. As we will see later, one of the <A HREF="repeat.html" TARGET="_top">star</A>'s effects is that it makes the <TT CLASS=regex>\d</TT>, in this case, optional. The engine will try to match <TT CLASS=regex>\d</TT> with the void after the string. That fails, but the star turns the failure of the <TT CLASS=regex>\d</TT> into a zero-width success. The engine will proceed with the next regex token, without advancing the position in the string. So the engine arrives at <TT CLASS=regex>$</TT>, and the void after the string. We already saw that those match. At this point, the entire regex has matched the empty string, and the engine reports success.</P> <H2>Caution for Programmers</H2> <P>A regular expression such as <TT CLASS=regex>$</TT> all by itself can indeed match after the string. If you would query the engine for the character position, it would return the length of the string if string indices are zero-based, or the length+1 if string indices are one-based in your programming language. If you would query the engine for the length of the match, it would return zero.</P> <P>What you have to watch out for is that String[Regex.MatchPosition] may cause an access violation or segmentation fault, because MatchPosition can point to the void after the string. This can also happen with <TT CLASS=regex>^</TT> and <TT CLASS=regex>^$</TT> if the last character in the string is a newline.</P><h2>Make a Donation</h2>
<p>Did this website just save you a trip to the bookstore?  Please <a href="donate.html">make a donation</a> to support this site, and you'll get a lifetime of advertisement-free access to this site!</p>
<DIV id=copyright>
<P CLASS=copyright>Page URL: <A HREF="anchors.html" TARGET="_top">http://www.Regular-Expressions.info/anchors.html</A><BR>
Page last updated: 21 April 2010<BR>
Site last updated: 17 June 2013<BR>
Copyright &copy; 2003-2013 Jan Goyvaerts. All rights reserved.</P>
</DIV> 

<script type="text/javascript"><!--
var google_conversion_id = 1072547447; var google_conversion_language = "en"; var google_conversion_format = "3"; var google_conversion_color = "666666"; var google_conversion_label = "sqPQCInO3QEQ94y3_wM"; var google_conversion_value = 0;
//-->
</script>
<script type="text/javascript" src="http://www.googleadservices.com/pagead/conversion.js"></script>
<noscript>
<div style="display:inline;">
<img height="1" width="1" style="border-style:none;" alt="" src="http://www.googleadservices.com/pagead/conversion/1072547447/?label=sqPQCInO3QEQ94y3_wM&amp;guid=ON&amp;script=0"/>
</div>
</noscript>
</DIV> 
<DIV id=side><script type="text/javascript">movecontent();</script><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="possessive.html" TARGET=_top>Possessive&nbsp;Quantifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="xmlcharclass.html" TARGET=_top>XML&nbsp;Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="posixbrackets.html" TARGET=_top>POSIX&nbsp;Bracket&nbsp;Expressions</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR><TR><TD><A HREF="freespacing.html" TARGET=_top>Free-Spacing</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Print&nbsp;PDF</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="updates.html" TARGET=_top>RSS&nbsp;Feed&nbsp;&amp;&nbsp;Blog</A></TD></TR></TABLE><iframe class="amazonsingle" src="http://rcm.amazon.com/e/cm?t=jgsbookselection&o=1&p=8&l=as1&asins=1449319432&md=10FE9736YVPPT7A0FBG2&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=000000&bg1=FFFFFF&f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe><div>
<script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><P>&nbsp;</P> <TABLE CLASS=sidead CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 4</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files or folders, or scan entire drives and network shares.</TD></TR> <TR><TD CLASS=ad>Search and replace using text, binary data or one or more regular expressions to automate repetitive editing tasks. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to rename files, copy files, or merge and split the contents of files. Work with plain text files, Unicode files, binary files, compressed files, and files in proprietary formats such as MS Office, OpenOffice, and PDF. Runs on Windows 2000, XP, Vista, 7, and 8.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV><script type="text/javascript">movecontent();</script></BODY></HTML>