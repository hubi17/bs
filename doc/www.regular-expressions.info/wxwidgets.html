<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>wxRegEx Class - wxWidgets Regular Expressions</TITLE>
<script src="regex.js" type="text/javascript"></script>
<link rel="alternate" type="application/rss+xml" title="Regex Guru" href="http://www.regexguru.com/feed/">
<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="Complete explanation of the wxRegEx class that adds support for advanced regular expressions to the wxWidgets library">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<script type="text/javascript">window.onresize = movecontent;</script>
<DIV id=top><DIV id=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<div id=btntop><table align=center cellspacing=0 cellpadding=0 border=0><tr><td><a href="tutorial.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tutorial</div></a></td><td><a href="tools.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tools&nbsp;&amp;&nbsp;Languages</div></a></td><td><a href="examples.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Examples</div></a></td><td><a href="books.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Books&nbsp;&amp;&nbsp;Reference</div></a></td></tr></table></div>
<DIV id=bodytext>
<script type="text/javascript">movecontent();</script>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/wxwidgets.html" TARGET="_top"><IMG SRC="img/regexbuddyad.png" width=203 height=145 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><B><A HREF="http://www.regexbuddy.com/wxwidgets.html" TARGET="_top">Easily use the powerful wxRegEx class</A> with RegexBuddy.</B><BR> Create and analyze regex patterns with RegexBuddy's intuitive regex building blocks. Implement regexes in your wxWidgets applications applications with instant C++ code using the wxRegEx class. Just tell RegexBuddy what you want to achieve, and copy and paste the auto-generated C++ code. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A>.</TD> </TR></TABLE>  <H1>wxWidgets Supports Three Regular Expression Flavors</H1> <P>wxWidgets uses the exact same regular expression engine that was developed by Henry Spencer for <A HREF="tcl.html" TARGET="_top">Tcl 8.2</A>. This means that wxWidgets supports the same three regular expressions flavors: <A HREF="tcl.html" TARGET="_top">Tcl Advanced Regular Expressions</A>, <a href="posix.html#ere">POSIX Extended Regular Expressions</a> and <a href="posix.html#bre">POSIX Basic Regular Expressions</a>. Unlike in Tcl, EREs rather than the far more powerful AREs are the default. The <tt>wxRegEx::Replace()</tt> method uses the same syntax for the replacement text as Tcl's <tt>regsub</tt> command.</p> <script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><h2>The wxRegEx Class</h2> <p>To use the wxWidgets regex engine, you need to instantiate the wxRegEx class. The class has two constructors. <tt><b>wxRegEx()</b></tt> creates an empty regex object. Before you can use the object, you have to call <tt>wxRegEx::Compile()</tt>. <tt>wxRegEx::IsValid</tt> will return false until you do.</p> <p><tt><b>wxRegEx</b>(const wxString& expr, int flags = wxRE_EXTENDED)</tt> creates a wxRegEx object with a compiled regular expression. The constructor will always create the object, even if your regular expression is invalid. Check <tt>wxRegEx::IsValid</tt> to determine if the regular expression was compiled successfully.</p> <p><tt>bool <b>wxRegEx::Compile</b>(const wxString& pattern, int flags = wxRE_EXTENDED)</tt> compiles a regular expression. You can call this method on any wxRegEx object, including one that already holds a compiled regular expression. Doing so will simply replace the regular expression held by the wxRegEx object. Pass your regular expression as a string as the first parameter. The second parameter allows you to set certain matching options.</p> <p>To set the regex flavor, specify one of the flags wxRE_EXTENDED, wxRE_ADVANCED or wxRE_BASIC. If you specify a flavor, wxRE_EXTENDED is the default. I recommend you always specify the wxRE_ADVANCED flag. AREs are far more powerful than EREs. Every valid ERE is also a valid ARE, and will give identical results. The only reason to use the ERE flavor is when your code has to work when wxWidgets is compiled without the "built-in" regular expression library (i.e. Henry Spencer's code).</p> <p>You can set three other flags in addition to the flavor. wxRE_ICASE makes the regular expression case insensitive. The default is case sensitive. wxRE_NOSUB makes the regex engine treat all <A HREF="brackets.html" TARGET="_top">capturing groups</A> as non-capturing. This means you won't be able to use backreferences in the replacement text, or query the part of the regex matched by each capturing group. If you won't be using these anyway, setting the wxRE_NOSUB flag improves performance.</p> <p>As discussed in the <A HREF="tcl.html" TARGET="_top">Tcl</A> section, Henry Spencer's "ARE" regex engine did away with the confusing "single line" <tt class=regex>(?s)</tt> and "multi line" <tt class=regex>(?m)</tt> matching modes, replacing them with the equally confusing "non-newline-sensitive" <tt class="regex">(?s)</tt>, "partial newline-sensitive" <tt class="regex">(?p)</tt>, "inverse partial newline-sensitive" <tt class="regex">(?w)</tt> and "newline-sensitive matching" <TT class="regex">(?n)</tt>. Since the wxRegEx class encapsulates the ARE engine, it supports all 4 modes when you use the mode modifiers inside the regular expression. But the <tt>flags</tt> parameter only allows you to set two.</p> <p>If you add wxRE_NEWLINE to the flags, you're turning on "newline-sensitive matching" <TT class="regex">(?n)</tt>. In this mode, the <A HREF="dot.html" TARGET="_top">dot</A> will not match newline characters (\n). The <A HREF="anchors.html" TARGET="_top">caret and dollar</A> will match after and before newlines in the string, as well as at the start and end of the subject string.</p> <p>If you don't set the wxRE_NEWLINE flag, the default is "non-newline-sensitive" <tt class="regex">(?s)</tt>. In this mode, the <A HREF="dot.html" TARGET="_top">dot</A> will match all characters, including newline characters (\n). The <A HREF="anchors.html" TARGET="_top">caret and dollar</A> will match only at the start and end of the subject string. Note that this default is different from the default in Perl and every other regex engine on the planet. In Perl, by default, the dot does not match newline characters, and the caret and dollar only match at the start and end of the subject string. The only way to set this mode in wxWidgets is to put <tt class="regex">(?p)</tt> at the start of your regex.</p> <p>Putting it all together, <tt>wxRegex(_T("(?p)^[a-z].*$"), wxRE_ADVANCED + wxRE_ICASE)</tt> will check if your subject string consists of a single line that starts with a letter. The equivalent in Perl is <tt>m/^[a-z].*$/i</tt>.</p> <h2>wxRegEx Status Functions</h2> <p><tt>wxRegEx::<b>IsValid()</b></tt> returns true when the wxRegEx object holds a compiled regular expression.</p> <p><tt>wxRegEx::<b>GetMatchCount()</b></tt> is rather poorly named. It does not return the number of matches found by <tt>Matches()</tt>. In fact, you can call <tt>GetMatchCount()</tt> right after <tt>Compile()</tt>, before you call <tt>Matches</tt>. <tt>GetMatchCount()</tt> it returns the number of <A HREF="brackets.html" TARGET="_top">capturing groups</A> in your regular expression, plus one for the overall regex match. You can use this to determine the number of backreferences you can use the replacement text, and the highest index you can pass to <tt>GetMatch()</tt>. If your regex has no capturing groups, <tt>GetMatchCount()</tt> returns 1. In that case, <tt>\0</tt> is the only valid backreference you can use in the replacement text.</p> <p><tt>GetMatchCount()</tt> returns 0 in case of an error. This will happen if the wxRegEx object does not hold a compiled regular expression, or if you compiled it with wxRE_NOSUB.</p> <h2>Finding and Extracting Matches</h2> <p>If you want to test whether a regex matches a string, or extract the substring matched by the regex, you first need to call the <tt>wxRegEx::<b>Matches()</b></tt> method. It has 3 variants, allowing you to pass wxChar or wxString as the subject string. When using a wxChar, you can specify the length as a third parameter. If you don't, wxStrLen() will be called to compute the length. If you plan to loop over all regex matches in a string, you should call wxStrLen() yourself outside the loop and pass the result to wxRegEx::Matches().</p> <p><tt class=code>bool wxRegEx::<b>Matches</b>(const wxChar* text, int flags = 0) const<br> bool wxRegEx::<b>Matches</b>(const wxChar* text, int flags, size_t len) const<br> bool wxRegEx::<b>Matches</b>(const wxString& text, int flags = 0) const</tt></p> <p>Matches() returns true if the regex matches all or part of the subject string that you passed in the <tt>text</tt> parameter. Add <A HREF="anchors.html" TARGET="_top">anchors</A> to your regex if you want to set whether the regex matches the whole subject string.</p> <p>Do not confuse the <tt>flags</tt> parameter with the one you pass to the <tt>Compile()</tt> method or the <tt>wxRegEx()</tt> constructor. All the flavor and matching mode options can only be set when compiling the regex.</p> <p>The Matches() method allows only two flags: wxRE_NOTBOL and wxRE_NOTEOL. If you set wxRE_NOTBOL, then <tt class=regex>^</tt> and <tt class=regex>\A</tt> will not match at the start of the string. They will still match after embedded newlines if you turned on that matching mode. Likewise, specifying wxRE_NOTEOL tells <tt class=regex>$</tt> and <tt class=regex>\Z</tt> not to match at the end of the string.</p> <p>wxRE_NOTBOL is commonly used to implement a "find next" routine. The wxRegEx class does not provide such a function. To find the second match in the string, you'll need to call wxRegEx::Matches() and pass it the part of the original subject string after the first match. Pass the wxRE_NOTBOL flag to indicate that you've cut off the start of the string you're passing.</p> <p>wxRE_NOTEOL can be useful if you're processing a large set of data, and you want to apply the regex before you've read the whole data. Pass wxRE_NOTEOL while calling wxRegEx::Matches() as long as you haven't read the entire string yet. Pass both wxRE_NOTBOL and wxRE_NOTEOL when doing a "find next" on incomplete data.</p> <p>After a call to <tt>Matches()</tt> returns true, and you compiled your regex without the wxRE_NOSUB flag, you can call <tt>GetMatch()</tt> to get details about the overall regex match, and the parts of the string matched by the <A HREF="brackets.html" TARGET="_top">capturing groups</A> in your regex.</p> <p><tt>bool wxRegEx::<b>GetMatch</b>(size_t* start, size_t* len, size_t index = 0) const</tt> retrieves the starting position of the match in the subject string, and the number of characters in the match.</p> <p><tt>wxString wxRegEx::<b>GetMatch</b>(const wxString& text, size_t index = 0) const</tt> returns the text that was matched.</p> <p>For both calls, set the index parameter to zero (or omit it) to get the overall regex match. Set 1 &lt;= index &lt; GetMatchCount() to get the match of a capturing group in your regular expression. To determine the number of a group, count the opening brackets in your regular expression from left to right.</p> <h2>Searching and Replacing</h2> <p>The wxRegEx class offers three methods to do a search-and-replace. <tt>Replace()</tt> is the method that does the actual work. You can use <tt>ReplaceAll()</tt> and <tt>ReplaceFirst()</tt> as more readable ways to specify the 3rd parameter to <tt>Replace()</tt>.</p> <p><tt>int wxRegEx::<b>ReplaceAll</b>(wxString* text, const wxString& replacement) const</tt> replaces all regex matches in <tt>text</tt> with <tt>replacement</tt>.</p> <p><tt>int wxRegEx::<b>ReplaceFirst</b>(wxString* text, const wxString& replacement) const</tt> replaces the first match of the regular expression in <tt>text</tt> with <tt>replacement</tt>.</p> <p><tt>int wxRegEx::<b>Replace</b>(wxString* text, const wxString& replacement, size_t maxMatches = 0) const</tt> allows you to specify how many replacements will be made. Passing 0 for <tt>maxMatches</tt> or omitting it does the same as <tt>ReplaceAll()</tt>. Setting it to 1 does the same as <tt>ReplaceFirst()</tt>. Pass a number greater than 1 to replace only the first maxMatches matches. If <tt>text</tt> contains fewer matches than you've asked for, then all matches will be replaced, without triggering an error.</p> <p>All three calls return the actual number of replacements made. They return zero if the regex failed to match the subject text. A return value of -1 indicates an error. The replacements are made directly to the wxString that you pass as the first parameter.</p> <p>wxWidgets uses the same syntax as <A HREF="tcl.html" TARGET="_top">Tcl</A> for the replacement text. You can use <tt>\0</tt> as a placeholder for the whole regex match, and <tt>\1</tt> through <tt>\9</tt> for the text matched by one of the first nine <A HREF="brackets.html" TARGET="_top">capturing groups</A>. You can also use <tt>&</tt> as a synonym of <tt>\0</tt>. Note that there's no backslash in front of the ampersand. <tt>&</tt> is substituted with the whole regex match, while <tt>\&</tt> is substituted with a literal ampersand. Use <tt>\\</tt> to insert a literal backslash. You only need to escape backslashes if they're followed by a digit, to prevent the combination from being seen as a backreference. When specifying the replacement text as a literal string in C++ code, you need to double up all the backslashes, as the C++ compiler also treats backslashes as escape characters. So if you want to replace the match with the first backreference followed by the text <tt class=string>&co</tt>, you'll need to code that in C++ as <tt>_T("\\1\\&co")</tt>.</p><h2>Make a Donation</h2>
<p>Did this website just save you a trip to the bookstore?  Please <a href="donate.html">make a donation</a> to support this site, and you'll get a lifetime of advertisement-free access to this site!</p>
<DIV id=copyright>
<P CLASS=copyright>Page URL: <A HREF="wxwidgets.html" TARGET="_top">http://www.Regular-Expressions.info/wxwidgets.html</A><BR>
Page last updated: 22 September 2010<BR>
Site last updated: 17 June 2013<BR>
Copyright &copy; 2003-2013 Jan Goyvaerts. All rights reserved.</P>
</DIV> 

<script type="text/javascript"><!--
var google_conversion_id = 1072547447; var google_conversion_language = "en"; var google_conversion_format = "3"; var google_conversion_color = "666666"; var google_conversion_label = "sqPQCInO3QEQ94y3_wM"; var google_conversion_value = 0;
//-->
</script>
<script type="text/javascript" src="http://www.googleadservices.com/pagead/conversion.js"></script>
<noscript>
<div style="display:inline;">
<img height="1" width="1" style="border-style:none;" alt="" src="http://www.googleadservices.com/pagead/conversion/1072547447/?label=sqPQCInO3QEQ94y3_wM&amp;guid=ON&amp;script=0"/>
</div>
</noscript>
</DIV> 
<DIV id=side><script type="text/javascript">movecontent();</script><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tools</TD></TR><TR><TD><A HREF="grep.html" TARGET=_top>grep</A></TD></TR><TR><TD><A HREF="powergrep.html" TARGET=_top>PowerGREP</A></TD></TR><TR><TD><A HREF="regexbuddy.html" TARGET=_top>RegexBuddy</A></TD></TR><TR><TD><A HREF="regexmagic.html" TARGET=_top>RegexMagic</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>General Applications</TD></TR><TR><TD><A HREF="editpadpro.html" TARGET=_top>EditPad&nbsp;Pro</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Languages &amp; Libraries</TD></TR><TR><TD><A HREF="delphi.html" TARGET=_top>Delphi</A></TD></TR><TR><TD><A HREF="gnu.html" TARGET=_top>GNU&nbsp;(Linux)</A></TD></TR><TR><TD><A HREF="groovy.html" TARGET=_top>Groovy</A></TD></TR><TR><TD><A HREF="java.html" TARGET=_top>Java</A></TD></TR><TR><TD><A HREF="javascript.html" TARGET=_top>JavaScript</A></TD></TR><TR><TD><A HREF="dotnet.html" TARGET=_top>.NET</A></TD></TR><TR><TD><A HREF="pcre.html" TARGET=_top>PCRE&nbsp;(C/C++)</A></TD></TR><TR><TD><A HREF="perl.html" TARGET=_top>Perl</A></TD></TR><TR><TD><A HREF="php.html" TARGET=_top>PHP</A></TD></TR><TR><TD><A HREF="posix.html" TARGET=_top>POSIX</A></TD></TR><TR><TD><A HREF="powershell.html" TARGET=_top>PowerShell</A></TD></TR><TR><TD><A HREF="python.html" TARGET=_top>Python</A></TD></TR><TR><TD><A HREF="rlanguage.html" TARGET=_top>R</A></TD></TR><TR><TD><A HREF="realbasic.html" TARGET=_top>REALbasic</A></TD></TR><TR><TD><A HREF="ruby.html" TARGET=_top>Ruby</A></TD></TR><TR><TD><A HREF="tcl.html" TARGET=_top>Tcl</A></TD></TR><TR><TD><A HREF="vbscript.html" TARGET=_top>VBScript</A></TD></TR><TR><TD><A HREF="vb.html" TARGET=_top>Visual&nbsp;Basic&nbsp;6</A></TD></TR><TR><TD><A HREF="wxwidgets.html" TARGET=_top>wxWidgets</A></TD></TR><TR><TD><A HREF="xml.html" TARGET=_top>XML&nbsp;Schema</A></TD></TR><TR><TD><A HREF="xpath.html" TARGET=_top>XQuery&nbsp;&amp;&nbsp;XPath</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Databases</TD></TR><TR><TD><A HREF="mysql.html" TARGET=_top>MySQL</A></TD></TR><TR><TD><A HREF="oracle.html" TARGET=_top>Oracle</A></TD></TR><TR><TD><A HREF="postgresql.html" TARGET=_top>PostgreSQL</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Print&nbsp;PDF</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="updates.html" TARGET=_top>RSS&nbsp;Feed&nbsp;&amp;&nbsp;Blog</A></TD></TR></TABLE><div>
<script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><P>&nbsp;</P> <TABLE CLASS=sidead CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 4</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files or folders, or scan entire drives and network shares.</TD></TR> <TR><TD CLASS=ad>Search and replace using text, binary data or one or more regular expressions to automate repetitive editing tasks. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to rename files, copy files, or merge and split the contents of files. Work with plain text files, Unicode files, binary files, compressed files, and files in proprietary formats such as MS Office, OpenOffice, and PDF. Runs on Windows 2000, XP, Vista, 7, and 8.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV><script type="text/javascript">movecontent();</script></BODY></HTML>