<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Regex Tutorial - Round Brackets for Grouping and Backreferences</TITLE>
<script src="regex.js" type="text/javascript"></script>
<link rel="alternate" type="application/rss+xml" title="Regex Guru" href="http://www.regexguru.com/feed/">
<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="In a regular expression, round brackets can be used to group regex tokens together and for creating backreferences.  Backreferences allow you to reuse part of the regex match in the regex, or in the replacement text.">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<script type="text/javascript">window.onresize = movecontent;</script>
<DIV id=top><DIV id=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<div id=btntop><table align=center cellspacing=0 cellpadding=0 border=0><tr><td><a href="tutorial.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tutorial</div></a></td><td><a href="tools.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tools&nbsp;&amp;&nbsp;Languages</div></a></td><td><a href="examples.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Examples</div></a></td><td><a href="books.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Books&nbsp;&amp;&nbsp;Reference</div></a></td></tr></table></div>
<DIV id=bodytext>
<script type="text/javascript">movecontent();</script>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/regexbuddyad.png" width=203 height=145 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><B><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>.</B><BR> Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this website, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A></TD> </TR></TABLE>  <H1>Use Round Brackets for Grouping</H1> <P>By placing part of a regular expression inside round brackets or parentheses, you can group that part of the regular expression together. This allows you to apply a regex operator, e.g. a <A HREF="repeat.html" TARGET="_top">repetition operator</A>, to the entire group. I have already used round brackets for this purpose in previous topics throughout this tutorial.</P> <P>Note that only round brackets can be used for grouping. Square brackets define a <A HREF="charclass.html" TARGET="_top">character class</A>, and curly braces are used by a <A HREF="repeat.html#limit">special repetition operator</A>.</P> <script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><H2>Round Brackets Create a Backreference</H2> <P>Besides grouping part of a regular expression together, round brackets also create a "backreference". A backreference stores the part of the string matched by the part of the regular expression inside the parentheses.</P> <P>That is, unless you use non-capturing parentheses. Remembering part of the regex match in a backreference, slows down the regex engine because it has more work to do. If you do not use the backreference, you can speed things up by using non-capturing parentheses, at the expense of making your regular expression slightly harder to read.</P> <P>The regex <TT CLASS=regex>Set(Value)?</TT> matches <TT CLASS=match>Set</TT> or <TT CLASS=match>SetValue</TT>. In the first case, the first backreference will be empty, because it did not match anything. In the second case, the first backreference will contain <TT CLASS=match>Value</TT>.</P> <P>If you do not use the backreference, you can optimize this regular expression into <TT CLASS=regex>Set(?:Value)?</TT>. The question mark and the colon after the opening round bracket are the special syntax that you can use to tell the regex engine that this pair of brackets should not create a backreference. Note the question mark after the opening bracket is unrelated to the question mark at the end of the regex. That question mark is the regex operator that makes the previous token <A HREF="optional.html" TARGET="_top">optional</A>. This operator cannot appear after an opening round bracket, because an opening bracket by itself is not a valid regex token. Therefore, there is no confusion between the question mark as an operator to make a token optional, and the question mark as a character to change the properties of a pair of round brackets. The colon indicates that the change we want to make is to turn off capturing the backreference.</P> <H2>How to Use Backreferences</H2> <P>Backreferences allow you to reuse part of the regex match. You can reuse it inside the regular expression (see below), or afterwards. What you can do with it afterwards, depends on the tool or programming language you are using. The most common usage is in search-and-replace operations. The replacement text will use a special syntax to allow text matched by capturing groups to be reinserted. This syntax differs greatly between various tools and languages, far more than the regex syntax does. Please check the <A HREF="refreplace.html" TARGET="_top">replacement text reference</A> for details.</p> <A NAME="usebackrefinregex"></A><H2>Using Backreferences in The Regular Expression</H2> <P>Backreferences can not only be used after a match has been found, but also during the match. Suppose you want to match a pair of opening and closing HTML tags, and the text in between. By putting the opening tag into a backreference, we can reuse the name of the tag for the closing tag. Here's how: <TT CLASS=regex>&lt;([A-Z][A-Z0-9]*)\b[^&gt;]*&gt;.*?&lt;/\1></TT> . This regex contains only one pair of parentheses, which capture the string matched by <TT CLASS=regex>[A-Z][A-Z0-9]*</TT> into the first backreference. This backreference is reused with <TT CLASS=regex>\1</TT> (backslash one). The <TT CLASS=regex>/</TT> before it is simply the forward slash in the closing HTML tag that we are trying to match.</P> <P>To figure out the number of a particular backreference, scan the regular expression from left to right and count the opening round brackets. The first bracket starts backreference number one, the second number two, etc. Non-capturing parentheses are not counted. This fact means that non-capturing parentheses have another benefit: you can insert them into a regular expression without changing the numbers assigned to the backreferences. This can be very useful when modifying a complex regular expression.</P> <P>You can reuse the same backreference more than once. <TT CLASS=regex>([a-c])x\1x\1</TT> will match <TT CLASS=match>axaxa</TT>, <TT CLASS=match>bxbxb</TT> and <TT CLASS=match>cxcxc</TT>.</P> <H2>Looking Inside The Regex Engine</H2> <P>Let's see how the regex engine applies the above regex to the string <TT CLASS=string>Testing &lt;B&gt;&lt;I&gt;bold italic&lt;/I&gt;&lt;/B&gt; text</TT>. The first token in the regex is the literal <TT CLASS=regex>&lt;</TT>. The regex engine will traverse the string until it can match at the first <TT CLASS=match>&lt;</TT> in the string. The next token is <TT CLASS=regex>[A-Z]</TT>. The regex engine also takes note that it is now inside the first pair of capturing parentheses. <TT CLASS=regex>[A-Z]</TT> matches <TT CLASS=match>B</TT>. The engine advances to <TT CLASS=regex>[A-Z0-9]</TT> and <TT CLASS=string>&gt;</TT>. This match fails. However, because of the <A HREF="repeat.html" TARGET="_top">star</A>, that's perfectly fine. The position in the string remains at <TT CLASS=string>&gt;</TT>. The position in the regex is advanced to <TT CLASS=regex>[^&gt;]</TT>.</P> <P>This step crosses the closing bracket of the first pair of capturing parentheses. This prompts the regex engine to store what was matched inside them into the first backreference. In this case, <TT CLASS=match>B</TT> is stored.</P> <P>After storing the backreference, the engine proceeds with the match attempt. <TT CLASS=regex>[^&gt;]</TT> does not match <TT CLASS=match>&gt;</TT>. Again, because of another star, this is not a problem. The position in the string remains at <TT CLASS=string>&gt;</TT>, and position in the regex is advanced to <TT CLASS=regex>&gt;</TT>. These obviously match. The next token is a dot, repeated by a lazy star. Because of the laziness, the regex engine will initially skip this token, taking note that it should backtrack in case the remainder of the regex fails.</P> <P>The engine has now arrived at the second <TT CLASS=regex>&lt;</TT> in the regex, and the second <TT CLASS=string>&lt;</TT> in the string. These match. The next token is <TT CLASS=regex>/</TT>. This does not match <TT CLASS=string>I</TT>, and the engine is forced to backtrack to the dot. The dot matches the second <TT CLASS=match>&lt;</TT> in the string. The star is still lazy, so the engine again takes note of the available backtracking position and advances to <TT CLASS=regex>&lt;</TT> and <TT CLASS=string>I</TT>. These do not match, so the engine again backtracks.</P> <P>The backtracking continues until the dot has consumed <TT CLASS=match>&lt;I&gt;bold italic</TT>. At this point, <TT CLASS=regex>&lt;</TT> matches the third <TT CLASS=match>&lt;</TT> in the string, and the next token is <TT CLASS=regex>/</TT> which matches <TT CLASS=string>/</TT>. The next token is <TT CLASS=regex>\1</TT>. Note that the token is the backreference, and not <TT CLASS=regex>B</TT>. The engine does not substitute the backreference in the regular expression. Every time the engine arrives at the backreference, it will read the value that was stored. This means that if the engine had backtracked beyond the first pair of capturing parentheses before arriving the second time at <TT CLASS=regex>\1</TT>, the new value stored in the first backreference would be used. But this did not happen here, so <TT CLASS=match>B</TT> it is. This fails to match at <TT CLASS=string>I</TT>, so the engine backtracks again, and the dot consumes the third <TT CLASS=string>&lt;</TT> in the string.</P> <P>Backtracking continues again until the dot has consumed <TT CLASS=match>&lt;I&gt;bold italic&lt;/I&gt;</TT>. At this point, <TT CLASS=regex>&lt;</TT> matches <TT CLASS=match>&lt;</TT> and <TT CLASS=regex>/</TT> matches <TT CLASS=match>/</TT>. The engine arrives again at <TT CLASS=regex>\1</TT>. The backreference still holds <TT CLASS=match>B</TT>. <TT CLASS=regex>B</TT> matches <TT CLASS=match>B</TT>. The last token in the regex, <TT CLASS=regex>&gt;</TT> matches <TT CLASS=match>&gt;</TT>. A complete match has been found: <TT CLASS=match>&lt;B&gt;&lt;I&gt;bold italic&lt;/I&gt;&lt;/B&gt;</TT>.</P> <h2>Backtracking Into Capturing Groups</h2> <p>You may have wondered about the word boundary <TT CLASS=regex>\b</TT> in the <TT CLASS=regex>&lt;([A-Z][A-Z0-9]*)\b[^&gt;]*&gt;.*?&lt;/\1></TT> mentioned above. This is to make sure the regex won't match incorrectly paired tags such as <tt class=string>&lt;boo>bold&lt;/b></tt>. You may think that cannot happen because the capturing group matches <tt class=match>boo</tt> which causes <tt class=regex>\1</tt> to try to match the same, and fail. That is indeed what happens. But then the regex engine backtracks.</p> <p>Let's take the regex <TT CLASS=regex>&lt;([A-Z][A-Z0-9]*)[^&gt;]*&gt;.*?&lt;/\1></TT> without the word boundary and look inside the regex engine at the point where <tt class=regex>\1</tt> fails the first time. First, <tt class=regex>.*?</tt> continues to expand until it has reached the end of the string, and <tt class=regex>&lt;/\1></TT> has failed to match each time <tt class=regex>.*?</tt> matched one more character.</p> <p>Then the regex engine backtracks into the capturing group. <tt class=regex>[A-Z0-9]*</tt> has matched <tt class=match>oo</tt>, but would just as happily match <tt class=match>o</tt> or nothing at all. When backtracking, <tt class=regex>[A-Z0-9]*</tt> is forced to give up one character. The regex engine continues, exiting the capturing group a second time. Since [A-Z][A-Z0-9]* has now matched <tt class=match>bo</tt>, that is what is stored into the capturing group, overwriting <tt class=match>boo</tt> that was stored before. <tt class=regex>[^&gt;]*</tt> matches the second <tt class=match>o</tt> in the opening tag. <TT CLASS=regex>&gt;.*?&lt;/</TT> matches <tt class=match>&gt;bold&lt;</tt>. <tt class=regex>\1</tt> fails again.</p> <p>The regex engine does all the same backtracking once more, until <tt class=regex>[A-Z0-9]*</tt> is forced to give up another character, causing it to match nothing, which the <A HREF="repeat.html" TARGET="_top">star</A> allows. The capturing group now stores just <tt class=match>b</tt>. <tt class=regex>[^&gt;]*</tt> now matches <tt class=match>oo</tt>. <TT CLASS=regex>&gt;.*?&lt;/</TT> once again matches <tt class=match>&gt;bold&lt;</tt>. <tt class=regex>\1</tt> now succeeds, as does <tt class=regex>&gt;</tt> and an overall match is found. But not the one we wanted.</p> <p>There are several solutions to this. One is to use the word boundary. When <tt class=regex>[A-Z0-9]*</tt> backtracks the first time, reducing the capturing group to <tt class=match>bo</tt>, <tt class=regex>\b</tt> fails to match between <tt class=string>o</tt> and <tt class=string>o</tt>. This forces <tt class=regex>[A-Z0-9]*</tt> to backtrack again immediately. The capturing group is reduced to <tt class=match>b</tt> and the word boundary fails between <tt class=string>b</tt> and <tt class=string>o</tt>. There are no further backtracking positions, so the whole match attempt fails.</p> <p>The reason we need the word boundary is that we're using <tt class=regex>[^&gt;]*</tt> to skip over any attributes in the tag. If your paired tags never have any attributes, you can leave that out, and use <TT CLASS=regex>&lt;([A-Z][A-Z0-9]*)&gt;.*?&lt;/\1></TT>. Each time <tt class=regex>[A-Z0-9]*</tt> backtracks, the <tt class=regex>&gt;</tt> that follows it will fail to match, quickly ending the match attempt.</p> <p>If you didn't expect the regex engine to backtrack into capturing groups, you can use an atomic group. The regex engine always backtracks into capturing groups, and never captures atomic groups. You can put the capturing group inside an atomic group to get an atomic capturing group: <tt class=regex>(?>(atomic capture))</tt>. In this case, we can put the whole opening tag into the atomic group: <TT CLASS=regex>(?>&lt;([A-Z][A-Z0-9]*)[^&gt;]*&gt;).*?&lt;/\1></TT>. The tutorial section on <A HREF="atomic.html" TARGET="_top">atomic grouping</A> has all the details.</p> <H2>Backreferences to Failed Groups</H2> <p>The previous section applies to all regex flavors, except those few that don't support capturing groups at all. Flavors behave differently when you start doing things that don't fit the "match the text matched by a previous capturing group" job description.</p> <p>There is a difference between a backreference to a capturing group that matched nothing, and one to a capturing group that did not participate in the match at all. The regex <tt class=regex>(q?)b\1</tt> will match <tt class=match>b</tt>. <tt class=regex>q?</tt> is optional and matches nothing, causing <tt class=regex>(q?)</tt> to successfully match and capture nothing. <tt class=regex>b</tt> matches <tt class=match>b</tt> and <tt class=regex>\1</tt> successfully matches the nothing captured by the group.</p> <p>The regex <tt class=regex>(q)?b\1</tt> however will fail to match <tt class=string>b</tt>. <tt class=regex>(q)</tt> fails to match at all, so the group never gets to capture anything at all. Because the whole group is optional, the engine does proceed to match <tt class=regex>b</tt>. However, the engine now arrives at <tt class=regex>\1</tt> which references a group that did not participate in the match attempt at all. This causes the backreference to fail to match at all, mimicking the result of the group. Since there's no <tt class=regex>?</tt> making <tt class=regex>\1</tt> optional, the overall match attempt fails.</p> <p>The only exception is <A HREF="javascript.html" TARGET="_top">JavaScript</A>. According to the official ECMA standard, a backreference to a non-participating capturing group must successfully match nothing just like a backreference to a participating group that captured nothing does. In other words, in JavaScript, <tt class=regex>(q?)b\1</tt> and <tt class=regex>(q)?b\1</tt> both match <tt class=match>b</tt>.</p> <a name="invalid"></a><H2>Forward References and Invalid References</H2> <p>Modern flavors, notably <A HREF="jgsoft.html" TARGET="_top">JGsoft</A>, <A HREF="dotnet.html" TARGET="_top">.NET</A>, <A HREF="java.html" TARGET="_top">Java</A>, <A HREF="perl.html" TARGET="_top">Perl</A>, <A HREF="pcre.html" TARGET="_top">PCRE</A> and <A HREF="ruby.html" TARGET="_top">Ruby</A> allow forward references. That is: you can use a backreference to a group that appears later in the regex. Forward references are obviously only useful if they're inside a repeated group. Then there can be situations in which the regex engine evaluates the backreference after the group has already matched. Before the group is attempted, the backreference will fail like a backreference to a failed group does.</p> <p>If forward references are supported, the regex <tt class=regex>(\2two|(one))+</tt> will match <tt class=match>oneonetwo</tt>. At the start of the string, <tt class=regex>\2</tt> fails. Trying the other <A HREF="alternation.html" TARGET="_top">alternative</A>, <tt class=match>one</tt> is matched by the second capturing group, and subsequently by the first group. The first group is then repeated. This time, <tt class=regex>\2</tt> matches <tt class=match>one</tt> as captured by the second group. <tt class=regex>two</tt> then matches <tt class=match>two</tt>. With two repetitions of the first group, the regex has matched the whole subject string.</p> <p>A nested reference is a backreference inside the capturing group that it references, e.g. <tt class=regex>(\1two|(one))+</tt>. This regex will give exactly the same behavior with flavors that support forward references. Some flavors that don't support forward references do support nested references. This includes <A HREF="javascript.html" TARGET="_top">JavaScript</A>.</p> <p>With all other flavors, using a backreference before its group in the regular expression is the same as using a backreference to a group that doesn't exist at all. All flavors discussed in this tutorial, except <A HREF="javascript.html" TARGET="_top">JavaScript</A> and <A HREF="ruby.html" TARGET="_top">Ruby</A>, treat backreferences to undefined groups as an error. In JavaScript and Ruby, they always result in a zero-width match. For Ruby this is a potential pitfall. In Ruby, <tt class=regex>(a)(b)?\2</tt> will fail to match <tt class=string>a</tt>, because <tt class=regex>\2</tt> references a non-participating group. But <tt class=regex>(a)(b)?\7</tt> will match <tt class=match>a</tt>. For JavaScript this is logical, as backreferences to non-participating groups do the same. Both regexes will match <tt class=match>a</tt>.</p> <A NAME="repeat"></A><H2>Repetition and Backreferences</H2> <P>As I mentioned in the above inside look, the regex engine does not permanently substitute backreferences in the regular expression. It will use the last match saved into the backreference each time it needs to be used. If a new match is found by capturing parentheses, the previously saved match is overwritten. There is a <A HREF="captureall.html" TARGET="_top">clear difference</A> between <TT CLASS=regex>([abc]+)</TT> and <TT CLASS=regex>([abc])+</TT>. Though both successfully match <TT CLASS=match>cab</TT>, the first regex will put <TT CLASS=match>cab</TT> into the first backreference, while the second regex will only store <TT CLASS=match>b</TT>. That is because in the second regex, the plus caused the pair of parentheses to repeat three times. The first time, <TT CLASS=match>c</TT> was stored. The second time <TT CLASS=match>a</TT> and the third time <TT CLASS=match>b</TT>. Each time, the previous value was overwritten, so <TT CLASS=match>b</TT> remains.</P> <P>This also means that <TT CLASS=regex>([abc]+)=\1</TT> will match <TT CLASS=match>cab=cab</TT>, and that <TT CLASS=regex>([abc])+=\1</TT> will not. The reason is that when the engine arrives at <TT CLASS=regex>\1</TT>, it holds <TT CLASS=regex>b</TT> which fails to match <TT CLASS=string>c</TT>. Obvious when you look at a simple example like this one, but a common cause of difficulty with regular expressions nonetheless. When using backreferences, always double check that you are really capturing what you want.</P> <H2>Useful Example: Checking for Doubled Words</H2> <P>When editing text, doubled words such as "the the" easily creep in. Using the regex <TT CLASS=regex>\b(\w+)\s+\1\b</TT> <A HREF="regexbuddy/doubledword.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A> in your <A HREF="editpadpro.html" TARGET="_top">text editor</A>, you can easily find them. To delete the second word, simply type in <TT CLASS=string>\1</TT> as the replacement text and click the Replace button.</P> <H2>Parentheses and Backreferences Cannot Be Used Inside Character Classes</H2> <P>Round brackets cannot be used inside <A HREF="charclass.html" TARGET="_top">character classes</A>, at least not as metacharacters. When you put a round bracket in a character class, it is treated as a literal character. So the regex <TT CLASS=regex>[(a)b]</TT> matches <TT CLASS=match>a</TT>, <TT CLASS=match>b</TT>, <TT CLASS=match>(</TT> and <TT CLASS=match>)</TT>.</P> <P>Backreferences also cannot be used inside a character class. The \1 in regex like <TT CLASS=regex>(a)[\1b]</TT> will be interpreted as an octal escape in most regex flavors. So this regex will match an <tt class=match>a</tt> followed by either <TT CLASS=regex>\x01</TT> or a <TT CLASS=regex>b</TT>.</P><h2>Make a Donation</h2>
<p>Did this website just save you a trip to the bookstore?  Please <a href="donate.html">make a donation</a> to support this site, and you'll get a lifetime of advertisement-free access to this site!</p>
<DIV id=copyright>
<P CLASS=copyright>Page URL: <A HREF="brackets.html" TARGET="_top">http://www.Regular-Expressions.info/brackets.html</A><BR>
Page last updated: 25 November 2010<BR>
Site last updated: 17 June 2013<BR>
Copyright &copy; 2003-2013 Jan Goyvaerts. All rights reserved.</P>
</DIV> 

<script type="text/javascript"><!--
var google_conversion_id = 1072547447; var google_conversion_language = "en"; var google_conversion_format = "3"; var google_conversion_color = "666666"; var google_conversion_label = "sqPQCInO3QEQ94y3_wM"; var google_conversion_value = 0;
//-->
</script>
<script type="text/javascript" src="http://www.googleadservices.com/pagead/conversion.js"></script>
<noscript>
<div style="display:inline;">
<img height="1" width="1" style="border-style:none;" alt="" src="http://www.googleadservices.com/pagead/conversion/1072547447/?label=sqPQCInO3QEQ94y3_wM&amp;guid=ON&amp;script=0"/>
</div>
</noscript>
</DIV> 
<DIV id=side><script type="text/javascript">movecontent();</script><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="possessive.html" TARGET=_top>Possessive&nbsp;Quantifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="xmlcharclass.html" TARGET=_top>XML&nbsp;Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="posixbrackets.html" TARGET=_top>POSIX&nbsp;Bracket&nbsp;Expressions</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR><TR><TD><A HREF="freespacing.html" TARGET=_top>Free-Spacing</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Print&nbsp;PDF</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="updates.html" TARGET=_top>RSS&nbsp;Feed&nbsp;&amp;&nbsp;Blog</A></TD></TR></TABLE><iframe class="amazonsingle" src="http://rcm.amazon.com/e/cm?t=jgsbookselection&o=1&p=8&l=as1&asins=1449319432&md=10FE9736YVPPT7A0FBG2&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=000000&bg1=FFFFFF&f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe><div>
<script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><P>&nbsp;</P> <TABLE CLASS=sidead CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 4</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files or folders, or scan entire drives and network shares.</TD></TR> <TR><TD CLASS=ad>Search and replace using text, binary data or one or more regular expressions to automate repetitive editing tasks. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to rename files, copy files, or merge and split the contents of files. Work with plain text files, Unicode files, binary files, compressed files, and files in proprietary formats such as MS Office, OpenOffice, and PDF. Runs on Windows 2000, XP, Vista, 7, and 8.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV><script type="text/javascript">movecontent();</script></BODY></HTML>