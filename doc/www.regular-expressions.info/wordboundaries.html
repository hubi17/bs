<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Regex Tutorial - \b Word Boundaries</TITLE>
<script src="regex.js" type="text/javascript"></script>
<link rel="alternate" type="application/rss+xml" title="Regex Guru" href="http://www.regexguru.com/feed/">
<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="In regular expressions, \b anchors the regex at a word boundary or the position between a word and a non-word character, or vice versa.">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<script type="text/javascript">window.onresize = movecontent;</script>
<DIV id=top><DIV id=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<div id=btntop><table align=center cellspacing=0 cellpadding=0 border=0><tr><td><a href="tutorial.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tutorial</div></a></td><td><a href="tools.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tools&nbsp;&amp;&nbsp;Languages</div></a></td><td><a href="examples.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Examples</div></a></td><td><a href="books.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Books&nbsp;&amp;&nbsp;Reference</div></a></td></tr></table></div>
<DIV id=bodytext>
<script type="text/javascript">movecontent();</script>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/regexbuddyad.png" width=203 height=145 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><B><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>.</B><BR> Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this website, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A></TD> </TR></TABLE>  <H1>Word Boundaries</H1> <P>The metacharacter <TT CLASS=regex>\b</TT> is an <A HREF="anchors.html" TARGET="_top">anchor</A> like the caret and the dollar sign. It matches at a position that is called a "word boundary". This match is zero-length.</P> <P>There are three different positions that qualify as word boundaries:</P> <UL> <LI>Before the first character in the string, if the first character is a word character. <LI>After the last character in the string, if the last character is a word character. <LI>Between two characters in the string, where one is a word character and the other is not a word character. </UL> <P>Simply put: <TT CLASS=regex>\b</TT> allows you to perform a "whole words only" search using a regular expression in the form of <TT CLASS=regex>\bword\b</TT>. A "word character" is a character that can be used to form words. All characters that are not "word characters" are "non-word characters".</p> <p>In all flavors, the characters <tt class=regex>[a-zA-Z0-9_]</tt> are word characters. These are also matched by the <A HREF="charclass.html#shorthand">short-hand character class</A> <TT CLASS=regex>\w</TT>. Flavors showing "ascii" for word boundaries in the <A HREF="refflavors.html" TARGET="_top">flavor comparison</A> recognize only these as word characters. Flavors showing "YES" also recognize letters and digits from other languages or all of Unicode as word characters. Notice that <A HREF="java.html" TARGET="_top">Java</A> supports Unicode for <tt class=regex>\b</tt> but not for <tt class=regex>\w</tt>. <A HREF="python.html" TARGET="_top">Python</A> offers flags to control which characters are word characters (affecting both <tt class=regex>\b</tt> and <tt class=regex>\w</tt>).</P> <P>In Perl and the other regex flavors discussed in this tutorial, there is only one metacharacter that matches both before a word and after a word. This is because any position between characters can never be both at the start and at the end of a word. Using only one operator makes things easier for you.</P> <P>Since digits are considered to be word characters, <TT CLASS=regex>\b4\b</TT> can be used to match a 4 that is not part of a larger number. This regex will not match <TT CLASS=string>44 sheets of a4</TT>. So saying "<TT CLASS=regex>\b</TT> matches before and after an alphanumeric sequence" is more exact than saying "before and after a word".</P> <A NAME="negated"></A><script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><H2>Negated Word Boundary</H2> <P><TT CLASS=regex>\B</TT> is the negated version of <TT CLASS=regex>\b</TT>. <TT CLASS=regex>\B</TT> matches at every position where <TT CLASS=regex>\b</TT> does not. Effectively, <TT CLASS=regex>\B</TT> matches at any position between two word characters as well as at any position between two non-word characters.</P> <H2>Looking Inside the Regex Engine</H2> <P>Let's see what happens when we apply the regex <TT CLASS=regex>\bis\b</TT> to the string <TT CLASS=string>This island is beautiful</TT>. The engine starts with the first token <TT CLASS=regex>\b</TT> at the first character <TT CLASS=string>T</TT>. Since this token is zero-length, the position before the character is inspected. <TT CLASS=regex>\b</TT> matches here, because the T is a word character and the character before it is the void before the start of the string. The engine continues with the next token: the literal <TT CLASS=regex>i</TT>. The engine does not advance to the next character in the string, because the previous regex token was zero-width. <TT CLASS=regex>i</TT> does not match <TT CLASS=string>T</TT>, so the engine retries the first token at the next character position.</P> <P><TT CLASS=regex>\b</TT> cannot match at the position between the <TT CLASS=string>T</TT> and the <TT CLASS=string>h</TT>. It cannot match between the <TT CLASS=string>h</TT> and the <TT CLASS=string>i</TT> either, and neither between the <TT CLASS=string>i</TT> and the <TT CLASS=string>s</TT>.</P> <P>The next character in the string is a space. <TT CLASS=regex>\b</TT> matches here because the space is not a word character, and the preceding character is. Again, the engine continues with the <TT CLASS=regex>i</TT> which does not match with the space.</P> <P>Advancing a character and restarting with the first regex token, <TT CLASS=regex>\b</TT> matches between the space and the second <TT CLASS=string>i</TT> in the string. Continuing, the regex engine finds that <TT CLASS=regex>i</TT> matches <TT CLASS=match>i</TT> and <TT CLASS=regex>s</TT> matches <TT CLASS=match>s</TT>. Now, the engine tries to match the second <TT CLASS=regex>\b</TT> at the position before the <TT CLASS=string>l</TT>. This fails because this position is between two word characters. The engine reverts to the start of the regex and advances one character to the <TT CLASS=string>s</TT> in <TT CLASS=string>island</TT>. Again, the <TT CLASS=regex>\b</TT> fails to match and continues to do so until the second space is reached. It matches there, but matching the <TT CLASS=regex>i</TT> fails.</P> <P>But <TT CLASS=regex>\b</TT> matches at the position before the third <TT CLASS=string>i</TT> in the string. The engine continues, and finds that <TT CLASS=regex>i</TT> matches <TT CLASS=match>i</TT> and <TT CLASS=regex>s</TT> matches <TT CLASS=match>s</TT>. The last token in the regex, <TT CLASS=regex>\b</TT>, also matches at the position before the third space in the string because the space is not a word character, and the character before it is.</P> <P>The engine has successfully matched the word <TT CLASS=match>is</TT> in our string, skipping the two earlier occurrences of the characters i and s. If we had used the regular expression <TT CLASS=regex>is</TT>, it would have matched the <TT CLASS=match>is</TT> in <TT CLASS=string>This</TT>.</P> <a name="tcl"></a><h2>Tcl Word Boundaries</h2> <p>Word boundaries, as described above, are supported by most regular expression flavors. Notable exceptions are the <A HREF="posix.html" TARGET="_top">POSIX</A> and <A HREF="xml.html" TARGET="_top">XML Schema</A> flavors, which don't support word boundaries at all. <A HREF="tcl.html" TARGET="_top">Tcl</A> uses a different syntax.</p> <p>In Tcl, <tt class=regex>\b</tt> matches a backspace character, just like <tt class=regex>\x08</tt> in most regex flavors (including Tcl's). <tt class=regex>\B</tt> matches a single backslash character in Tcl, just like <tt class=regex>\\</tt> in all other regex flavors (and Tcl too).</p> <p>Tcl uses the letter "y" instead of the letter "b" to match word boundaries. <tt class=regex>\y</tt> matches at any word boundary position, while <tt class=regex>\Y</tt> matches at any position that is not a word boundary. These Tcl regex tokens match exactly the same as <tt class=regex>\b</tt> and <tt class=regex>\B</tt> in Perl-style regex flavors. They don't discriminate between the start and the end of a word.</p> <p>Tcl has two more word boundary tokens that do discriminate between the start and end of a word. <tt class=regex>\m</tt> matches only at the start of a word. That is, it matches at any position that has a non-word character to the left of it, and a word character to the right of it. It also matches at the start of the string if the first character in the string is a word character. <tt class=regex>\M</tt> matches only at the end of a word. It matches at any position that has a word character to the left of it, and a non-word character to the right of it. It also matches at the end of the string if the last character in the string is a word character.</p> <p>The only regex engine that supports Tcl-style word boundaries (besides Tcl itself) is the <A HREF="jgsoft.html" TARGET="_top">JGsoft engine</A>. In <A HREF="powergrep.html" TARGET="_top">PowerGREP</A> and <A HREF="editpadpro.html" TARGET="_top">EditPad Pro</A>, <tt class=regex>\b</tt> and <tt class=regex>\B</tt> are Perl-style word boundaries, and <tt class=regex>\y</tt>, <tt class=regex>\Y</tt>, <tt class=regex>\m</tt> and <tt class=regex>\M</tt> are Tcl-style word boundaries.</p> <p>In most situations, the lack of <tt class=regex>\m</tt> and <tt class=regex>\M</tt> tokens is not a problem. <tt class=regex>\yword\y</tt> finds "whole words only" occurrences of "word" just like <tt class=regex>\mword\M</tt> would. <tt class=regex>\Mword\m</tt> could never match anywhere, since <tt class=regex>\M</tt> never matches at a position followed by a word character, and <tt class=regex>\m</tt> never at a position preceded by one. If your regular expression needs to match characters before or after <tt class=regex>\y</tt>, you can easily specify in the regex whether these characters should be word characters or non-word characters. E.g. if you want to match any word, <tt class=regex>\y\w+\y</tt> will give the same result as <tt class=regex>\m.+\M</tt>. Using <tt class=regex>\w</tt> instead of the dot automatically restricts the first <tt class=regex>\y</tt> to the start of a word, and the second <tt class=regex>\y</tt> to the end of a word. Note that <tt class=regex>\y.+\y</tt> would not work. This regex matches each word, and also each sequence of non-word characters between the words in your subject string. That said, if your flavor supports <tt class=regex>\m</tt> and <tt class=regex>\M</tt>, the regex engine could apply <tt class=regex>\m\w+\M</tt> slightly faster than <tt class=regex>\y\w+\y</tt>, depending on its internal optimizations.</p> <p>If your regex flavor supports <A HREF="lookaround.html" TARGET="_top">lookahead and lookbehind</A>, you can use <tt class=regex>(?&lt;!\w)(?=\w)</tt> to emulate Tcl's <tt class=regex>\m</tt> and <tt class=regex>(?&lt;=\w)(?!\w)</tt> to emulate <tt class=regex>\M</tt>. Though quite a bit more verbose, these lookaround constructs match exactly the same as Tcl's word boundaries.</p> <p>If your flavor has lookahead but not lookbehind, and also has Perl-style word boundaries, you can use <tt class=regex>\b(?=\w)</tt> to emulate Tcl's <tt class=regex>\m</tt> and <tt class=regex>\b(?!\w)</tt> to emulate <tt class=regex>\M</tt>. <tt class=regex>\b</tt> matches at the start or end of a word, and the lookahead checks if the next character is part of a word or not. If it is we're at the start of a word. Otherwise, we're at the end of a word.</p> <a name="gnu"><h2>GNU Word Boundaries</h2> <P>The <A HREF="gnu.html" TARGET="_top">GNU extensions</A> to POSIX regular expressions add support for the <tt class="regex">\b</tt> and <tt class=regex>\B</tt> word boundaries, as described above. GNU also uses its own syntax for start-of-word and end-of-word boundaries. <tt class=regex>\&lt;</tt> matches at the start of a word, like Tcl's <tt class=regex>\m</tt>. <tt class=regex>\&gt;</tt> matches at the end of a word, like Tcl's <tt class=regex>\M</tt>.<h2>Make a Donation</h2>
<p>Did this website just save you a trip to the bookstore?  Please <a href="donate.html">make a donation</a> to support this site, and you'll get a lifetime of advertisement-free access to this site!</p>
<DIV id=copyright>
<P CLASS=copyright>Page URL: <A HREF="wordboundaries.html" TARGET="_top">http://www.Regular-Expressions.info/wordboundaries.html</A><BR>
Page last updated: 27 February 2013<BR>
Site last updated: 17 June 2013<BR>
Copyright &copy; 2003-2013 Jan Goyvaerts. All rights reserved.</P>
</DIV> 

<script type="text/javascript"><!--
var google_conversion_id = 1072547447; var google_conversion_language = "en"; var google_conversion_format = "3"; var google_conversion_color = "666666"; var google_conversion_label = "sqPQCInO3QEQ94y3_wM"; var google_conversion_value = 0;
//-->
</script>
<script type="text/javascript" src="http://www.googleadservices.com/pagead/conversion.js"></script>
<noscript>
<div style="display:inline;">
<img height="1" width="1" style="border-style:none;" alt="" src="http://www.googleadservices.com/pagead/conversion/1072547447/?label=sqPQCInO3QEQ94y3_wM&amp;guid=ON&amp;script=0"/>
</div>
</noscript>
</DIV> 
<DIV id=side><script type="text/javascript">movecontent();</script><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="possessive.html" TARGET=_top>Possessive&nbsp;Quantifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="xmlcharclass.html" TARGET=_top>XML&nbsp;Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="posixbrackets.html" TARGET=_top>POSIX&nbsp;Bracket&nbsp;Expressions</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR><TR><TD><A HREF="freespacing.html" TARGET=_top>Free-Spacing</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Print&nbsp;PDF</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="updates.html" TARGET=_top>RSS&nbsp;Feed&nbsp;&amp;&nbsp;Blog</A></TD></TR></TABLE><iframe class="amazonsingle" src="http://rcm.amazon.com/e/cm?t=jgsbookselection&o=1&p=8&l=as1&asins=1449319432&md=10FE9736YVPPT7A0FBG2&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=000000&bg1=FFFFFF&f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe><P>&nbsp;</P> <TABLE CLASS=sidead CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 4</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files or folders, or scan entire drives and network shares.</TD></TR> <TR><TD CLASS=ad>Search and replace using text, binary data or one or more regular expressions to automate repetitive editing tasks. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to rename files, copy files, or merge and split the contents of files. Work with plain text files, Unicode files, binary files, compressed files, and files in proprietary formats such as MS Office, OpenOffice, and PDF. Runs on Windows 2000, XP, Vista, 7, and 8.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV><script type="text/javascript">movecontent();</script></BODY></HTML>