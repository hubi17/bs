<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Regex Tutorial - Lookahead and Lookbehind Zero-Width Assertions</TITLE>
<script src="regex.js" type="text/javascript"></script>
<link rel="alternate" type="application/rss+xml" title="Regex Guru" href="http://www.regexguru.com/feed/">
<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="Perl 5 expanded the regular expression syntax with zero-width assertions that allow you to test for a match, or test for failure, without actually consuming any characters.">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<script type="text/javascript">window.onresize = movecontent;</script>
<DIV id=top><DIV id=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<div id=btntop><table align=center cellspacing=0 cellpadding=0 border=0><tr><td><a href="tutorial.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tutorial</div></a></td><td><a href="tools.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tools&nbsp;&amp;&nbsp;Languages</div></a></td><td><a href="examples.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Examples</div></a></td><td><a href="books.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Books&nbsp;&amp;&nbsp;Reference</div></a></td></tr></table></div>
<DIV id=bodytext>
<script type="text/javascript">movecontent();</script>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/regexbuddyad.png" width=203 height=145 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><B><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>.</B><BR> Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this website, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A></TD> </TR></TABLE>  <H1>Lookahead and Lookbehind Zero-Width Assertions</H1> <P>Perl 5 introduced two very powerful constructs: "lookahead" and "lookbehind". Collectively, these are called "lookaround". They are also called "zero-width assertions". They are zero-width just like the <A HREF="anchors.html" TARGET="_top">start and end of line</A>, and <A HREF="wordboundaries.html" TARGET="_top">start and end of word</A> anchors that I already explained. The difference is that lookarounds will actually match characters, but then give up the match and only return the result: match or no match. That is why they are called "assertions". They do not consume characters in the string, but only assert whether a match is possible or not. Lookarounds allow you to create regular expressions that are impossible to create without them, or that would get very longwinded without them.</P> <A NAME="lookahead"></A><script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><H2>Positive and Negative Lookahead</H2> <P>Negative lookahead is indispensable if you want to match something not followed by something else. When explaining <A HREF="charclass.html" TARGET="_top">character classes</A>, I already explained why you cannot use a negated character class to match a "q" not followed by a "u". Negative lookahead provides the solution: <TT CLASS=regex>q(?!u)</TT>. The negative lookahead construct is the pair of round brackets, with the opening bracket followed by a question mark and an exclamation point. Inside the lookahead, we have the trivial regex <TT CLASS=regex>u</TT>.</P> <P>Positive lookahead works just the same. <TT CLASS=regex>q(?=u)</TT> matches a q that is followed by a u, without making the u part of the match. The positive lookahead construct is a pair of round brackets, with the opening bracket followed by a question mark and an equals sign.</P> <P>You can use any regular expression inside the lookahead. (Note that this is not the case with lookbehind. I will explain why below.) Any valid regular expression can be used inside the lookahead. If it contains capturing parentheses, the backreferences will be saved. Note that the lookahead itself does not create a backreference. So it is not included in the count towards numbering the backreferences. If you want to store the match of the regex inside a backreference, you have to put capturing parentheses around the regex inside the lookahead, like this: <TT CLASS=regex>(?=(regex))</TT>. The other way around will not work, because the lookahead will already have discarded the regex match by the time the backreference is to be saved.</P> <H2>Regex Engine Internals</H2> <P>First, let's see how the engine applies <TT CLASS=regex>q(?!u)</TT> to the string <TT CLASS=string>Iraq</TT>. The first token in the regex is the <A HREF="characters.html" TARGET="_top">literal</A> <TT CLASS=regex>q</TT>. As we already know, this will cause the engine to traverse the string until the <TT CLASS=match>q</TT> in the string is matched. The position in the string is now the void behind the string. The next token is the lookahead. The engine takes note that it is inside a lookahead construct now, and begins matching the regex inside the lookahead. So the next token is <TT CLASS=regex>u</TT>. This does not match the void behind the string. The engine notes that the regex inside the lookahead failed. Because the lookahead is negative, this means that the lookahead has successfully matched at the current position. At this point, the entire regex has matched, and <TT CLASS=match>q</TT> is returned as the match.</P> <P>Let's try applying the same regex to <TT CLASS=string>quit</TT>. <TT CLASS=regex>q</TT> matches <TT CLASS=match>q</TT>. The next token is the <TT CLASS=regex>u</TT> inside the lookahead. The next character is the <TT CLASS=string>u</TT>. These match. The engine advances to the next character: <TT CLASS=string>i</TT>. However, it is done with the regex inside the lookahead. The engine notes success, and discards the regex match. This causes the engine to step back in the string to <TT CLASS=string>u</TT>.</P> <P>Because the lookahead is negative, the successful match inside it causes the lookahead to fail. Since there are no other permutations of this regex, the engine has to start again at the beginning. Since <TT CLASS=regex>q</TT> cannot match anywhere else, the engine reports failure.</P> <P>Let's take one more look inside, to make sure you understand the implications of the lookahead. Let's apply <TT CLASS=regex>q(?=u)i</TT> to <TT CLASS=string>quit</TT>. I have made the lookahead positive, and put a token after it. Again, <TT CLASS=regex>q</TT> matches <TT CLASS=match>q</TT> and <TT CLASS=regex>u</TT> matches <TT CLASS=match>u</TT>. Again, the match from the lookahead must be discarded, so the engine steps back from <TT CLASS=string>i</TT> in the string to <TT CLASS=string>u</TT>. The lookahead was successful, so the engine continues with <TT CLASS=regex>i</TT>. But <TT CLASS=regex>i</TT> cannot match <TT CLASS=string>u</TT>. So this match attempt fails. All remaining attempts will fail as well, because there are no more q's in the string.</P> <A NAME="lookbehind"></A><H2>Positive and Negative Lookbehind</H2> <P>Lookbehind has the same effect, but works backwards. It tells the regex engine to temporarily step backwards in the string, to check if the text inside the lookbehind can be matched there. <TT CLASS=regex>(?&lt;!a)b</TT> matches a "b" that is not preceded by an "a", using negative lookbehind. It will not match <TT CLASS=string>cab</TT>, but will match the <TT CLASS=match>b</TT> (and only the <TT CLASS=match>b</TT>) in <TT CLASS=string>bed</TT> or <TT CLASS=string>debt</TT>. <TT CLASS=regex>(?&lt;=a)b</TT> (positive lookbehind) matches the <TT CLASS=match>b</TT> (and only the <TT CLASS=match>b</TT>) in <TT CLASS=match>cab</TT>, but does not match <TT CLASS=string>bed</TT> or <TT CLASS=string>debt</TT>.</P> <P>The construct for positive lookbehind is <TT CLASS=regex>(?&lt;=text)</TT>: a pair of round brackets, with the opening bracket followed by a question mark, "less than" symbol and an equals sign. Negative lookbehind is written as <TT CLASS=regex>(?&lt;!text)</TT>, using an exclamation point instead of an equals sign.</P> <H2>More Regex Engine Internals</H2> <P>Let's apply <TT CLASS=regex>(?&lt;=a)b</TT> to <TT CLASS=string>thingamabob</TT>. The engine starts with the lookbehind and the first character in the string. In this case, the lookbehind tells the engine to step back one character, and see if an "a" can be matched there. The engine cannot step back one character because there are no characters before the <TT CLASS=string>t</TT>. So the lookbehind fails, and the engine starts again at the next character, the <TT CLASS=string>h</TT>. (Note that a negative lookbehind would have succeeded here.) Again, the engine temporarily steps back one character to check if an "a" can be found there. It finds a <TT CLASS=string>t</TT>, so the positive lookbehind fails again.</P> <P>The lookbehind continues to fail until the regex reaches the <TT CLASS=string>m</TT> in the string. The engine again steps back one character, and notices that the <TT CLASS=match>a</TT> can be matched there. The positive lookbehind matches. Because it is zero-width, the current position in the string remains at the <TT CLASS=string>m</TT>. The next token is <TT CLASS=regex>b</TT>, which cannot match here. The next character is the second <TT CLASS=string>a</TT> in the string. The engine steps back, and finds out that the <TT CLASS=string>m</TT> does not match <TT CLASS=regex>a</TT>.</P> <P>The next character is the first <TT CLASS=string>b</TT> in the string. The engine steps back and finds out that <TT CLASS=match>a</TT> satisfies the lookbehind. <TT CLASS=regex>b</TT> matches <TT CLASS=match>b</TT>, and the entire regex has been matched successfully. It matches one character: the first <TT CLASS=match>b</TT> in the string.</P> <A NAME="limitbehind"></A><H2>Important Notes About Lookbehind</H2> <P>The good news is that you can use lookbehind anywhere in the regex, not only at the start. If you want to find a word not ending with an "s", you could use <TT CLASS=regex>\b\w+(?&lt;!s)\b</TT>. This is definitely not the same as <TT CLASS=regex>\b\w+[^s]\b</TT>. When applied to <TT CLASS=string>John's</TT>, the former will match <TT CLASS=match>John</TT> and the latter <TT CLASS=match>John'</TT> (including the apostrophe). I will leave it up to you to figure out why. (Hint: <TT CLASS=regex>\b</TT> matches between the apostrophe and the <TT CLASS=string>s</TT>). The latter will also not match single-letter words like "a" or "I". The correct regex without using lookbehind is <TT CLASS=regex>\b\w*[^s\W]\b</TT> (star instead of plus, and \W in the character class). Personally, I find the lookbehind easier to understand. The last regex, which works correctly, has a double negation (the \W in the negated character class). Double negations tend to be confusing to humans. Not to regex engines, though.</P> <P>The bad news is that most regex flavors do not allow you to use just any regex inside a lookbehind, because they cannot apply a regular expression backwards. Therefore, the regular expression engine needs to be able to figure out how many steps to step back before checking the lookbehind.</P> <P>Therefore, many regex flavors, including those used by <A HREF="perl.html" TARGET="_top">Perl</A> and <A HREF="python.html" TARGET="_top">Python</A>, only allow fixed-length strings. You can use any regex of which the length of the match can be predetermined. This means you can use <A HREF="characters.html" TARGET="_top">literal text</A> and <A HREF="charclass.html" TARGET="_top">character classes</A>. You cannot use <A HREF="repeat.html" TARGET="_top">repetition</A> or <A HREF="optional.html" TARGET="_top">optional items</A>. You can use <A HREF="alternation.html" TARGET="_top">alternation</A>, but only if all options in the alternation have the same length.</P> <p>PCRE is not fully Perl-compatible when it comes to lookbehind. While Perl requires alternatives inside lookbehind to have the same length, PCRE allows alternatives of variable length. Each alternative still has to be fixed-length.</p> <P><A HREF="java.html" TARGET="_top">Java</A> takes things a step further by allowing finite repetition. You still cannot use the <A HREF="repeat.html" TARGET="_top">star</A> or <A HREF="repeat.html" TARGET="_top">plus</A>, but you can use the <A HREF="optional.html" TARGET="_top">question mark</A> and the <A HREF="repeat.html" TARGET="_top">curly braces</A> with the max parameter specified. Java recognizes the fact that finite repetition can be rewritten as an alternation of strings with different, but fixed lengths. Unfortunately, the JDK 1.4 and 1.5 have some bugs when you use alternation inside lookbehind. These were fixed in JDK 1.6.</P> <P>The only regex engines that allow you to use a full regular expression inside lookbehind, including infinite repetition, are the <A HREF="jgsoft.html" TARGET="_top">JGsoft engine</A> and the <A HREF="dotnet.html" TARGET="_top">.NET framework RegEx classes</A>.</P> <P>Finally, flavors like <A HREF="javascript.html" TARGET="_top">JavaScript</A>, <A HREF="ruby.html" TARGET="_top">Ruby</A> and <A HREF="tcl.html" TARGET="_top">Tcl</A> do not support lookbehind at all, even though they do support lookahead.</P> <H2>Lookaround Is Atomic</H2> <P>The fact that lookaround is zero-width automatically makes it <a href="atomic.html#use">atomic</a>. As soon as the lookaround condition is satisfied, the regex engine forgets about everything inside the lookaround. It will not backtrack inside the lookaround to try different permutations.</P> <P>The only situation in which this makes any difference is when you use <A HREF="brackets.html" TARGET="_top">capturing groups</A> inside the lookaround. Since the regex engine does not backtrack into the lookaround, it will not try different permutations of the capturing groups.</P> <P>For this reason, the regex <tt class=regex>(?=(\d+))\w+\1</tt> will never match <tt class=string>123x12</tt>. First the lookaround captures <tt class=match>123</tt> into <tt class=regex>\1</tt>. <tt class=regex>\w+</tt> then matches the whole string and backtracks until it matches only <tt class=match>1</tt>. Finally, <tt class=regex>\w+</tt> fails since <tt class=regex>\1</tt> cannot be matched at any position. Now, the regex engine has nothing to backtrack to, and the overall regex fails. The backtracking steps created by <tt class=regex>\d+</tt> have been discarded. It never gets to the point where the lookahead captures only <tt class=string>12</tt>.</P> <P>Obviously, the regex engine does try further positions in the string. If we change the subject string, the regex <tt class=regex>(?=(\d+))\w+\1</tt> will match <tt class=match>56x56</tt> in <tt class=string>456x56</tt>.</P> <P>If you don't use capturing groups inside lookaround, then all this doesn't matter. Either the lookaround condition can be satisfied or it cannot be. In how many ways it can be satisfied is irrelevant.</P><h2>Make a Donation</h2>
<p>Did this website just save you a trip to the bookstore?  Please <a href="donate.html">make a donation</a> to support this site, and you'll get a lifetime of advertisement-free access to this site!</p>
<DIV id=copyright>
<P CLASS=copyright>Page URL: <A HREF="lookaround.html" TARGET="_top">http://www.Regular-Expressions.info/lookaround.html</A><BR>
Page last updated: 21 April 2010<BR>
Site last updated: 17 June 2013<BR>
Copyright &copy; 2003-2013 Jan Goyvaerts. All rights reserved.</P>
</DIV> 

<script type="text/javascript"><!--
var google_conversion_id = 1072547447; var google_conversion_language = "en"; var google_conversion_format = "3"; var google_conversion_color = "666666"; var google_conversion_label = "sqPQCInO3QEQ94y3_wM"; var google_conversion_value = 0;
//-->
</script>
<script type="text/javascript" src="http://www.googleadservices.com/pagead/conversion.js"></script>
<noscript>
<div style="display:inline;">
<img height="1" width="1" style="border-style:none;" alt="" src="http://www.googleadservices.com/pagead/conversion/1072547447/?label=sqPQCInO3QEQ94y3_wM&amp;guid=ON&amp;script=0"/>
</div>
</noscript>
</DIV> 
<DIV id=side><script type="text/javascript">movecontent();</script><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="possessive.html" TARGET=_top>Possessive&nbsp;Quantifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="xmlcharclass.html" TARGET=_top>XML&nbsp;Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="posixbrackets.html" TARGET=_top>POSIX&nbsp;Bracket&nbsp;Expressions</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR><TR><TD><A HREF="freespacing.html" TARGET=_top>Free-Spacing</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Print&nbsp;PDF</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="updates.html" TARGET=_top>RSS&nbsp;Feed&nbsp;&amp;&nbsp;Blog</A></TD></TR></TABLE><iframe class="amazonsingle" src="http://rcm.amazon.com/e/cm?t=jgsbookselection&o=1&p=8&l=as1&asins=1449319432&md=10FE9736YVPPT7A0FBG2&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=000000&bg1=FFFFFF&f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe><div>
<script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><P>&nbsp;</P> <TABLE CLASS=sidead CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 4</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files or folders, or scan entire drives and network shares.</TD></TR> <TR><TD CLASS=ad>Search and replace using text, binary data or one or more regular expressions to automate repetitive editing tasks. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to rename files, copy files, or merge and split the contents of files. Work with plain text files, Unicode files, binary files, compressed files, and files in proprietary formats such as MS Office, OpenOffice, and PDF. Runs on Windows 2000, XP, Vista, 7, and 8.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV><script type="text/javascript">movecontent();</script></BODY></HTML>