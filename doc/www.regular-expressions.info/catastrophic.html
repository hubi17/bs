<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Runaway Regular Expressions: Catastrophic Backtracking</TITLE>
<script src="regex.js" type="text/javascript"></script>
<link rel="alternate" type="application/rss+xml" title="Regex Guru" href="http://www.regexguru.com/feed/">
<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="This is the reason why your regular expression takes forever, or crashes your program.">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<script type="text/javascript">window.onresize = movecontent;</script>
<DIV id=top><DIV id=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<div id=btntop><table align=center cellspacing=0 cellpadding=0 border=0><tr><td><a href="tutorial.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tutorial</div></a></td><td><a href="tools.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tools&nbsp;&amp;&nbsp;Languages</div></a></td><td><a href="examples.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Examples</div></a></td><td><a href="books.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Books&nbsp;&amp;&nbsp;Reference</div></a></td></tr></table></div>
<DIV id=bodytext>
<script type="text/javascript">movecontent();</script>
 <TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/debug.html" TARGET="_top"><IMG SRC="img/regexbuddyad.png" width=203 height=145 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><B><A HREF="http://www.regexbuddy.com/debug.html" TARGET="_top">Figure out why your regular expression isn't working</A> with RegexBuddy.</B><BR> RegexBuddy's regular expression debugger offers you a unique view inside the regular expression engine. It shows you exactly how and why your regex works, or doesn't. Stop guessing. Fix your regular expressions with knowledge instead of by trial and error. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A>.</TD> </TR></TABLE>  <H1>Runaway Regular Expressions: Catastrophic Backtracking</H1> <p>Consider the regular expression <tt class=regex>(x+x+)+y</tt>. Before you scream in horror and say this contrived example should be written as <tt class=regex>xx+y</tt> to match exactly the same without those terribly nested quantifiers: just assume that each "x" represents something more complex, with certain strings being matched by both "x". See the section on HTML files below for a real example.</p> <p>Let's see what happens when you apply this regex to <tt class=string>xxxxxxxxxxy</tt>. The first <tt class=regex>x+</tt> will match all 10 <tt class=match>x</tt> characters. The second <tt class=regex>x+</tt> fails. The first <tt class=regex>x+</tt> then backtracks to 9 matches, and the second one picks up the remaining <tt class=match>x</tt>. The group has now matched once. The group repeats, but fails at the first <tt class=regex>x+</tt>. Since one repetition was sufficient, the group matches. <tt class=regex>y</tt> matches <tt class=match>y</tt> and an overall match is found. The regex is declared functional, the code is shipped to the customer, and his computer explodes. Almost.</p> <p>The above regex turns ugly when the <tt class=string>y</tt> is missing from the subject string. When <tt class=regex>y</tt> fails, the regex engine backtracks. The group has one iteration it can backtrack into. The second <tt class=regex>x+</tt> matched only one <tt class=match>x</tt>, so it can't backtrack. But the first <tt class=regex>x+</tt> can give up one <tt class=string>x</tt>. The second <tt class=regex>x+</tt> promptly matches <tt class=match>xx</tt>. The group again has one iteration, fails the next one, and the <tt class=regex>y</tt> fails. Backtracking again, the second <tt class=regex>x+</tt> now has one backtracking position, reducing itself to match <tt class=match>x</tt>. The group tries a second iteration. The first <tt class=regex>x+</tt> matches but the second is stuck at the end of the string. Backtracking again, the first <tt class=regex>x+</tt> in the group's first iteration reduces itself to 7 characters. The second <tt class=regex>x+</tt> matches <tt class=match>xxx</tt>. Failing <tt class=regex>y</tt>, the second <tt class=regex>x+</tt> is reduced to <tt class=match>xx</tt> and then <tt class=match>x</tt>. Now, the group can match a second iteration, with one <tt class=match>x</tt> for each <tt class=regex>x+</tt>. But this (7,1),(1,1) combination fails too. So it goes to (6,4) and then (6,2)(1,1) and then (6,1),(2,1) and then (6,1),(1,2) and then I think you start to get the drift.</p> <p>If you try this regex on a 10x string in <A HREF="http://www.regexbuddy.com/debug.html" TARGET="_top">RegexBuddy's debugger</A>, it'll take 2558 steps to figure out the final <tt class=regex>y</tt> is missing. For an 11x string, it needs 5118 steps. For 12, it takes 10238 steps. Clearly we have an exponential complexity of O(2^n) here. At 21x the debugger bows out at 2.8 million steps, diagnosing a bad case of catastrophic backtracking.</p> <p>RegexBuddy is forgiving in that it detects it's going in circles, and aborts the match attempt. Other regex engines (like .NET) will keep going forever, while others will crash with a stack overflow (like Perl, before version 5.10). Stack overflows are particularly nasty on Windows, since they tend to make your application vanish without a trace or explanation. Be very careful if you run a web service that allows users to supply their own regular expressions. People with little regex experience have surprising skill at coming up with exponentially complex regular expressions.</p> <script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><h2>Possessive Quantifiers and Atomic Grouping to The Rescue</h2> <p>In the above example, the sane thing to do is obviously to rewrite it as <tt class=regex>xx+y</tt> which eliminates the nested quantifiers entirely. Nested quantifiers are <A HREF="repeat.html" TARGET="_top">repeated</A> or <A HREF="alternation.html" TARGET="_top">alternated</A> tokens inside a group that is itself repeated or alternated. These almost always lead to catastrophic backtracking. About the only situation where they don't is when the start of each alternative inside the group is not optional, and mutually exclusive with the start of all the other alternatives, and mutually exclusive with the token that follows it (inside its alternative inside the group). E.g. <tt class=regex>(a+b+|c+d+)+y</tt> is safe. If anything fails, the regex engine will backtrack through the whole regex, but it will do so linearly. The reason is that all the tokens are mutually exclusive. None of them can match any characters matched by any of the others. So the match attempt at each backtracking position will fail, causing the regex engine to backtrack linearly. If you test this on <tt class=string>aaaabbbbccccdddd</tt>, RegexBuddy needs only 13 steps rather than millions of steps to figure it out.</p> <p>However, it's not always possible or easy to rewrite your regex to make everything mutually exclusive. So we need a way to tell the regex engine not to backtrack. When we've grabbed all the x's, there's no need to backtrack. There couldn't possibly be a <tt class=string>y</tt> in anything matched by either <tt class=regex>x+</tt>. Using a <A HREF="possessive.html" TARGET="_top">possessive quantifier</A>, our regex becomes <tt class=regex>(x+x+)++y</tt>. This fails the 21x string in merely 7 steps. That's 6 steps to match all the x's, and 1 step to figure out that <tt class=regex>y</tt> fails. Almost no backtracking is done. Using an <A HREF="atomic.html" TARGET="_top">atomic group</A>, the regex becomes <tt class=regex>(?>(x+x+)+)y</tt> with the exact same results.</p> <h2>A Real Example: Matching CSV Records</h2> <p>Here's a real example from a technical support case I once handled. The customer was trying to find lines in a comma-delimited text file where the 12th item on a line started with a <TT CLASS=string>P</TT>. He was using the innocently-looking regexp <TT CLASS=regex>^(.*?,){11}P</TT> <A HREF="regexbuddy/atomicproblem.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A>.</P> <P>At first sight, this regex looks like it should do the job just fine. The lazy dot and comma match a single comma-delimited field, and the {11} skips the first 11 fields. Finally, the P checks if the 12th field indeed starts with P. In fact, this is exactly what will happen when the 12th field indeed starts with a P.</P> <P>The problem rears its ugly head when the 12th field does not start with a P. Let's say the string is <TT CLASS=string>1,2,3,4,5,6,7,8,9,10,11,12,13</TT>. At that point, the regex engine will backtrack. It will backtrack to the point where <TT CLASS=regex>^(.*?,){11}</TT> had consumed <TT CLASS=match>1,2,3,4,5,6,7,8,9,10,11</TT>, giving up the last match of the comma. The next token is again the dot. The dot matches a comma. <I>The dot matches the comma!</I> However, the comma does not match the <TT CLASS=string>1</TT> in the 12th field, so the dot continues until the 11th iteration of <TT CLASS=regex>.*?,</TT> has consumed <TT CLASS=match>11,12,</TT>. You can already see the root of the problem: the part of the regex (the dot) matching the contents of the field also matches the delimiter (the comma). Because of the double repetition (star inside {11}), this leads to a catastrophic amount of backtracking.</P> <P>The regex engine now checks whether the 13th field starts with a P. It does not. Since there is no comma after the 13th field, the regex engine can no longer match the 11th iteration of <TT CLASS=regex>.*?,</TT>. But it does not give up there. It backtracks to the 10th iteration, expanding the match of the 10th iteration to <TT CLASS=match>10,11,</TT>. Since there is still no P, the 10th iteration is expanded to <TT CLASS=match>10,11,12,</TT>. Reaching the end of the string again, the same story starts with the 9th iteration, subsequently expanding it to <TT CLASS=match>9,10,</TT>, <TT CLASS=match>9,10,11,</TT>, <TT CLASS=match>9,10,11,12,</TT>. But between each expansion, there are more possibilities to be tried. When the 9th iteration consumes <TT CLASS=match>9,10,</TT>, the 10th could match just <TT CLASS=match>11,</TT> as well as <TT CLASS=match>11,12,</TT>. Continuously failing, the engine backtracks to the 8th iteration, again trying all possible combinations for the 9th, 10th, and 11th iterations.</P> <P>You get the idea: the possible number of combinations that the regex engine will try for each line where the 12th field does not start with a P is huge. All this would take a long time if you ran this regex on a large CSV file where most rows don't have a P at the start of the 12th field.</P> <H2>Preventing Catastrophic Backtracking</H2> <P>The solution is simple. When nesting repetition operators, make absolutely sure that there is only one way to match the same match. If repeating the inner loop 4 times and the outer loop 7 times results in the same overall match as repeating the inner loop 6 times and the outer loop 2 times, you can be sure that the regex engine will try all those combinations.</P> <P>In our example, the solution is to be more exact about what we want to match. We want to match 11 comma-delimited fields. The fields must not contain comma's. So the regex becomes: <TT CLASS=regex>^([^,\r\n]*,){11}P</TT> <A HREF="regexbuddy/atomicsolution.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A>. If the P cannot be found, the engine will still backtrack. But it will backtrack only 11 times, and each time the <TT CLASS=regex>[^,\r\n]</TT> is not able to expand beyond the comma, forcing the regex engine to the previous one of the 11 iterations immediately, without trying further options.</P> <a name="rxb"></a><H2>See the Difference with RegexBuddy</H2> <P>If you try this example with <A HREF="http://www.regexbuddy.com/debug.html" TARGET="_top">RegexBuddy's debugger</A>, you will see that the original regex <TT CLASS=regex>^(.*?,){11}P</TT> needs 29,685 steps to conclude there regex cannot match <TT CLASS=string>1,2,3,4,5,6,7,8,9,10,11,12</TT>. If the string is <TT CLASS=string>1,2,3,4,5,6,7,8,9,10,11,12,13</TT>, just 3 characters more, the number of steps doubles to 60,313. It's not too hard to imagine that at this kind of exponential rate, attempting this regex on a large file with long lines could easily take forever.</P> <p><img src="screens/rxbcatastrophic.png" alt="Evidence of catastrophic backtracking in RegexBuddy"></p> <P>Our improved regex <TT CLASS=regex>^([^,\r\n]*,){11}P</TT>, however, needs just forty-eight steps to fail, whether the subject string has 12 numbers, 13 numbers, 16 numbers or a billion. While the complexity of the original regex was exponential, the complexity of the improved regex is constant with respect to whatever follows the 12th field. The reason is the regex fails immediately when it discovers the 12th field doesn't start with a P. It simply backtracks 12 times without expanding again, and that's it.</p> <p>The complexity of the improved regex is linear to the length of the first 11 fields. 36 steps are needed in our example. That's the best we can do, since the engine does have to scan through all the characters of the first 11 fields to find out where the 12th one begins. Our improved regex is a perfect solution.</P> <p><img src="screens/rxbconstant.png" alt="Proof of backtracking in constant time in RegexBuddy"></p> <H2>Alternative Solution Using Atomic Grouping</h2> <P>In the above example, we could easily reduce the amount of backtracking to a very low level by better specifying what we wanted. But that is not always possible in such a straightforward manner. In that case, you should use atomic grouping to prevent the regex engine from backtracking.</P> <P>Using <A HREF="atomic.html" TARGET="_top">atomic grouping</A>, the above regex becomes <TT CLASS=regex>^<B>(?></B>(.*?,){11}<B>)</B>P</TT>. Everything between <TT>(?>)</TT> is treated as one single token by the regex engine, once the regex engine leaves the group. Because the entire group is one token, no backtracking can take place once the regex engine has found a match for the group. If backtracking is required, the engine has to backtrack to the regex token before the group (the caret in our example). If there is no token before the group, the regex must retry the entire regex at the next position in the string.</P> <P>Let's see how <TT CLASS=regex>^(?>(.*?,){11})P</TT> is applied to <TT CLASS=string>1,2,3,4,5,6,7,8,9,10,11,12,13</TT>. The caret matches at the start of the string and the engine enters the atomic group. The star is lazy, so the dot is initially skipped. But the comma does not match <TT CLASS=string>1</TT>, so the engine backtracks to the dot. That's right: backtracking is allowed here. The star is not possessive, and is not immediately enclosed by an atomic group. That is, the regex engine did not cross the closing round bracket of the atomic group. The dot matches <TT CLASS=match>1</TT>, and the comma matches too. <TT CLASS=regex>{11}</TT> causes further repetition until the atomic group has matched <TT CLASS=match>1,2,3,4,5,6,7,8,9,10,11,</TT>.</P> <P>Now, the engine leaves the atomic group. Because the group is atomic, all backtracking information is discarded and the group is now considered a single token. The engine now tries to match <TT CLASS=regex>P</TT> to the <TT CLASS=string>1</TT> in the 12th field. This fails.</P> <P>So far, everything happened just like in the original, troublesome regular expression. Now comes the difference. <TT CLASS=regex>P</TT> failed to match, so the engine backtracks. The previous token is an atomic group, so the group's entire match is discarded and the engine backtracks further to the caret. The engine now tries to match the caret at the next position in the string, which fails. The engine walks through the string until the end, and declares failure. Failure is declared after 30 attempts to match the caret, and just one attempt to match the atomic group, rather than after 30 attempts to match the caret and a huge number of attempts to try all combinations of both quantifiers in the regex.</P> <P>That is what atomic grouping and possessive quantifiers are for: efficiency by disallowing backtracking. The most efficient regex for our problem at hand would be <TT CLASS=regex>^(?>((?>[^,\r\n]*),){11})P</TT> <A HREF="regexbuddy/atomic.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A>, since possessive, greedy repetition of the star is faster than a backtracking lazy dot. If possessive quantifiers are available, you can reduce clutter by writing <TT CLASS=regex>^(?>([^,\r\n]*+,){11})P</TT> <A HREF="regexbuddy/atomicpossessive.html"><IMG SRC="img/rxb.gif" WIDTH="16" HEIGHT="16" ALIGN=middle ALT="Analyze this regular expression with RegexBuddy" BORDER=0></A>.</P> <a name="example"></a><H2>Quickly Matching a Complete HTML File</H2> <p>Another common situation where catastrophic backtracking occurs is when trying to match "something" followed by "anything" followed by "another something" followed by "anything", where the lazy dot <tt class=regex>.*?</tt> is used. The more "anything", the more backtracking. Sometimes, the lazy dot is simply a symptom of a lazy programmer. <tt class=regex>".*?"</tt> is not appropriate to match a double-quoted string, since you don't really want to allow anything between the quotes. A string can't have (unescaped) embedded quotes, so <tt class=regex>"[^"\r\n]*"</tt> is more appropriate, and won't lead to catastrophic backtracking when combined in a larger regular expression. However, sometimes "anything" really is just that. The problem is that "another something" also qualifies as "anything", giving us a genuine <tt class=regex>x+x+</tt> situation.</p> <P>Suppose you want to use a regular expression to match a complete HTML file, and extract the basic parts from the file. If you know the structure of HTML files, writing the regex <TT class=regex>&lt;html>.*?&lt;head>.*?&lt;title>.*?&lt;/title>.*?&lt;/head>.*?&lt;body[^>]*>.*?&lt;/body>.*?&lt;/html></tt> is very straight-forward. With the "dot matches newlines" or "single line" <A HREF="modifiers.html" TARGET="_top">matching mode</A> turned on, it will work just fine on valid HTML files.</P> <P>Unfortunately, this regular expression won't work nearly as well on an HTML file that misses some of the tags. The worst case is a missing &lt;/html> tag at the end of the file. When <tt class="regex">&lt;/html></tt> fails to match, the regex engine backtracks, giving up the match for <tt class="regex">&lt;/body>.*?</tt>. It will then further expand the lazy dot before <tt class="regex">&lt;/body></tt>, looking for a second closing <tt class="string">&lt;/body></tt> tag in the HTML file. When that fails, the engine gives up <tt class=regex>&lt;body[^>]*>.*?</tt>, and starts looking for a second opening <tt class=string>&lt;body[^>]*></tt> tag all the way to the end of the file. Since that also fails, the engine proceeds looking all the way to the end of the file for a second closing head tag, a second closing title tag, etc.</P> <P>If you run this regex in <A HREF="http://www.regexbuddy.com/debug.html" TARGET="_top">RegexBuddy's debugger</A>, the output will look like a sawtooth. The regex matches the whole file, backs up a little, matches the whole file again, backs up some more, backs up yet some more, matches everything again, etc. until each of the 7 <tt class=regex>.*?</tt> tokens has reached the end of the file. The result is that this regular has a worst case complexity of N^7. If you double the length of the HTML file with the missing &lt;html> tag by appending text at the end, the regular expression will take 128 times (2^7) as long to figure out the HTML file isn't valid. This isn't quite as disastrous as the 2^N complexity of our first example, but will lead to very unacceptable performance on larger invalid files.</P> <P>In this situation, we know that each of the literal text blocks in our regular expression (the HTML tags, which function as delimiters) will occur only once in a valid HTML file. That makes it very easy to package each of the lazy dots (the delimited content) in an atomic group.</P> <P><tt class=regex>&lt;html>(?>.*?&lt;head>)(?>.*?&lt;title>)(?>.*?&lt;/title>)(?>.*?&lt;/head>)(?>.*?&lt;body[^>]*>)(?>.*?&lt;/body>).*?&lt;/html></tt> will match a valid HTML file in the same number of steps as the original regex. The gain is that it will fail on an invalid HTML file almost as fast as it matches a valid one. When <tt class="regex">&lt;/html></tt> fails to match, the regex engine backtracks, giving up the match for the last lazy dot. But then, there's nothing further to backtrack to. Since all of the lazy dots are in an atomic group, the regex engines has discarded their backtracking positions. The groups function as a "do not expand further" roadblock. The regex engine is forced to announce failure immediately.</p> <p>I'm sure you've noticed that each atomic group also contains an HTML tag after the lazy dot. This is critical. We do allow the lazy dot to backtrack until its matching HTML tag was found. E.g. when <tt class="regex">.*?&lt;/body></tt> is processing <tt class=string>Last paragraph&lt;/p>&lt;/body></tt>, the <tt class=regex>&lt;/</tt> regex tokens will match <tt class="match">&lt;/</tt> in <tt class="string">&lt;/p></tt>. However, <tt class=regex>b</tt> will fail <tt class=string>p</tt>. At that point, the regex engine will backtrack and expand the lazy dot to include <tt class="match">&lt;/p></tt>. Since the regex engine hasn't left the atomic group yet, it is free to backtrack inside the group. Once <tt class=regex>&lt;/body></tt> has matched, and the regex engine leaves the atomic group, it discards the lazy dot's backtracking positions. Then it can no longer be expanded.</p> <P>Essentially, what we've done is to bind a repeated regex token (the lazy dot to match HTML content) to the non-repeated regex token that follows it (the literal HTML tag). Since anything, including HTML tags, can appear between the HTML tags in our regular expression, we cannot use a negated character class instead of the lazy dot to prevent the delimiting HTML tags from being matched as HTML content. But we can and did achieve the same result by combining each lazy dot and the HTML tag following it into an atomic group. As soon as the HTML tag is matched, the lazy dot's match is locked down. This ensures that the lazy dot will never match the HTML tag that should be matched by the literal HTML tag in the regular expression.</P><h2>Make a Donation</h2>
<p>Did this website just save you a trip to the bookstore?  Please <a href="donate.html">make a donation</a> to support this site, and you'll get a lifetime of advertisement-free access to this site!</p>
<DIV id=copyright>
<P CLASS=copyright>Page URL: <A HREF="catastrophic.html" TARGET="_top">http://www.Regular-Expressions.info/catastrophic.html</A><BR>
Page last updated: 17 June 2009<BR>
Site last updated: 17 June 2013<BR>
Copyright &copy; 2003-2013 Jan Goyvaerts. All rights reserved.</P>
</DIV> 

<script type="text/javascript"><!--
var google_conversion_id = 1072547447; var google_conversion_language = "en"; var google_conversion_format = "3"; var google_conversion_color = "666666"; var google_conversion_label = "sqPQCInO3QEQ94y3_wM"; var google_conversion_value = 0;
//-->
</script>
<script type="text/javascript" src="http://www.googleadservices.com/pagead/conversion.js"></script>
<noscript>
<div style="display:inline;">
<img height="1" width="1" style="border-style:none;" alt="" src="http://www.googleadservices.com/pagead/conversion/1072547447/?label=sqPQCInO3QEQ94y3_wM&amp;guid=ON&amp;script=0"/>
</div>
</noscript>
</DIV> 
<DIV id=side><script type="text/javascript">movecontent();</script><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Examples</TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="numericranges.html" TARGET=_top>Numeric&nbsp;Ranges</A></TD></TR><TR><TD><A HREF="floatingpoint.html" TARGET=_top>Floating&nbsp;Point&nbsp;Numbers</A></TD></TR><TR><TD><A HREF="email.html" TARGET=_top>Email&nbsp;Addresses</A></TD></TR><TR><TD><A HREF="dates.html" TARGET=_top>Valid&nbsp;Dates</A></TD></TR><TR><TD><A HREF="creditcard.html" TARGET=_top>Credit&nbsp;Card&nbsp;Numbers</A></TD></TR><TR><TD><A HREF="completelines.html" TARGET=_top>Matching&nbsp;Complete&nbsp;Lines</A></TD></TR><TR><TD><A HREF="duplicatelines.html" TARGET=_top>Deleting&nbsp;Duplicate&nbsp;Lines</A></TD></TR><TR><TD><A HREF="examplesprogrammer.html" TARGET=_top>Programming</A></TD></TR><TR><TD><A HREF="near.html" TARGET=_top>Two&nbsp;Near&nbsp;Words</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Pitfalls</TD></TR><TR><TD><A HREF="catastrophic.html" TARGET=_top>Catastrophic&nbsp;Backtracking</A></TD></TR><TR><TD><A HREF="floatingpoint.html" TARGET=_top>Making&nbsp;Everything&nbsp;Optional</A></TD></TR><TR><TD><A HREF="captureall.html" TARGET=_top>Repeated&nbsp;Capturing&nbsp;Group</A></TD></TR><TR><TD><A HREF="unicode8bit.html" TARGET=_top>Mixing&nbsp;Unicode&nbsp;&amp;&nbsp;8-bit</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Print&nbsp;PDF</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="updates.html" TARGET=_top>RSS&nbsp;Feed&nbsp;&amp;&nbsp;Blog</A></TD></TR></TABLE><iframe class="amazonsingle" src="http://rcm.amazon.com/e/cm?t=jgsbookselection&o=1&p=8&l=as1&asins=1449319432&md=10FE9736YVPPT7A0FBG2&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=000000&bg1=FFFFFF&f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe><P>&nbsp;</P> <TABLE CLASS=sidead CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 4</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files or folders, or scan entire drives and network shares.</TD></TR> <TR><TD CLASS=ad>Search and replace using text, binary data or one or more regular expressions to automate repetitive editing tasks. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to rename files, copy files, or merge and split the contents of files. Work with plain text files, Unicode files, binary files, compressed files, and files in proprietary formats such as MS Office, OpenOffice, and PDF. Runs on Windows 2000, XP, Vista, 7, and 8.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV><script type="text/javascript">movecontent();</script></BODY></HTML>