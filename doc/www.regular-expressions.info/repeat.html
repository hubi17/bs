<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Regex Tutorial - Repetition with Star and Plus</TITLE>
<script src="regex.js" type="text/javascript"></script>
<link rel="alternate" type="application/rss+xml" title="Regex Guru" href="http://www.regexguru.com/feed/">
<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="In a regular expression, the asterisk or star causes the preceding token to be matched zero or more times, and the plus one or more times.">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<script type="text/javascript">window.onresize = movecontent;</script>
<DIV id=top><DIV id=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<div id=btntop><table align=center cellspacing=0 cellpadding=0 border=0><tr><td><a href="tutorial.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tutorial</div></a></td><td><a href="tools.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tools&nbsp;&amp;&nbsp;Languages</div></a></td><td><a href="examples.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Examples</div></a></td><td><a href="books.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Books&nbsp;&amp;&nbsp;Reference</div></a></td></tr></table></div>
<DIV id=bodytext>
<script type="text/javascript">movecontent();</script>
<TABLE CLASS=topad> <TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top"><IMG SRC="img/regexbuddyad.png" width=203 height=145 ALT="RegexBuddy" BORDER=0></A></TD> <TD CLASS=topad><B><A HREF="http://www.regexbuddy.com/create.html" TARGET="_top">Easily create and understand regular expressions today</A>.</B><BR> Compose and analyze regex patterns with RegexBuddy's easy-to-grasp regex blocks and intuitive regex tree, instead of or in combination with the traditional regex syntax. Developed by the author of this website, RegexBuddy makes learning and using regular expressions easier than ever. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A></TD> </TR></TABLE>  <H1>Repetition with Star and Plus</H1> <P>I already introduced one repetition operator or quantifier: the <A HREF="optional.html" TARGET="_top">question mark</A>. It tells the engine to attempt to match the preceding token zero times or once, in effect making it optional.</P> <P>The asterisk or star tells the engine to attempt to match the preceding token zero or more times. The plus tells the engine to attempt to match the preceding token once or more. <TT CLASS=regex>&lt;[A-Za-z][A-Za-z0-9]*&gt;</TT> matches an HTML tag without any attributes. The sharp brackets are <A HREF="characters.html" TARGET="_top">literals</A>. The first <A HREF="charclass.html" TARGET="_top">character class</A> matches a letter. The second character class matches a letter or digit. The star repeats the second character class. Because we used the star, it's OK if the second character class matches nothing. So our regex will match a tag like <TT CLASS=match>&lt;B&gt;</TT>. When matching <TT CLASS=match>&lt;HTML&gt;</TT>, the first character class will match <TT CLASS=match>H</TT>. The star will cause the second character class to be repeated three times, matching <TT CLASS=match>T</TT>, <TT CLASS=match>M</TT> and <TT CLASS=match>L</TT> with each step.</P> <P>I could also have used <TT CLASS=regex>&lt;[A-Za-z0-9]+&gt;</TT>. I did not, because this regex would match <TT CLASS=match>&lt;1&gt;</TT>, which is not a valid HTML tag. But this regex may be sufficient if you know the string you are searching through does not contain any such invalid tags.</P> <A NAME="limit"></A><script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><H2>Limiting Repetition</H2> <P>Modern regex flavors, like those discussed in this tutorial, have an additional repetition operator that allows you to specify how many times a token can be repeated. The syntax is <TT>{<I>min</I>,<I>max</I>}</TT>, where <I>min</I> is a positive integer number indicating the minimum number of matches, and <I>max</I> is an integer equal to or greater than <I>min</I> indicating the maximum number of matches. If the comma is present but <I>max</I> is omitted, the maximum number of matches is infinite. So <TT CLASS=regex>{0,}</TT> is the same as <TT CLASS=regex>*</TT>, and <TT CLASS=regex>{1,}</TT> is the same as <TT CLASS=regex>+</TT>. Omitting both the comma and <I>max</I> tells the engine to repeat the token exactly <I>min</I> times.</P> <P>You could use <TT CLASS=regex>\b[1-9][0-9]{3}\b</TT> to match a number between 1000 and 9999. <TT CLASS=regex>\b[1-9][0-9]{2,4}\b</TT> matches a number between 100 and 99999. Notice the use of the <A HREF="wordboundaries.html" TARGET="_top">word boundaries</A>.</P> <A NAME="greedy"></A><H2>Watch Out for The Greediness!</H2> <P>Suppose you want to use a regex to match an HTML tag. You know that the input will be a valid HTML file, so the regular expression does not need to exclude any invalid use of sharp brackets. If it sits between sharp brackets, it is an HTML tag.</P> <P>Most people new to regular expressions will attempt to use <TT CLASS=regex>&lt;.+&gt;</TT>. They will be surprised when they test it on a string like <TT CLASS=string>This is a &lt;EM&gt;first&lt;/EM&gt; test</TT>. You might expect the regex to match <TT CLASS=match>&lt;EM&gt;</TT> and when continuing after that match, <TT CLASS=match>&lt;/EM&gt;</TT>.</P> <P>But it does not. The regex will match <TT CLASS=match>&lt;EM&gt;first&lt;/EM&gt;</TT>. Obviously not what we wanted. The reason is that the plus is <I>greedy</I>. That is, the plus causes the regex engine to repeat the preceding token as often as possible. Only if that causes the entire regex to fail, will the regex engine <I>backtrack</I>. That is, it will go back to the plus, make it give up the last iteration, and proceed with the remainder of the regex. Let's take a look inside the regex engine to see in detail how this works and why this causes our regex to fail. After that, I will present you with two possible solutions.</P> <P>Like the plus, the star and the repetition using curly braces are greedy.</P> <H2>Looking Inside The Regex Engine</H2> <P>The first token in the regex is <TT CLASS=regex>&lt;</TT>. This is a <A HREF="characters.html" TARGET="_top">literal</A>. As we already know, the first place where it will match is the first <TT CLASS=match>&lt;</TT> in the string. The next token is the dot, which matches any character except newlines. The dot is repeated by the plus. The plus is <I>greedy</I>. Therefore, the engine will repeat the dot as many times as it can. The dot matches <TT CLASS=match>E</TT>, so the regex continues to try to match the dot with the next character. <TT CLASS=match>M</TT> is matched, and the dot is repeated once more. The next character is the <TT CLASS=string>&gt;</TT>. You should see the problem by now. The dot matches the <TT CLASS=match>&gt;</TT>, and the engine continues repeating the dot. The dot will match all remaining characters in the string. The dot fails when the engine has reached the void after the end of the string. Only at this point does the regex engine continue with the next token: <TT CLASS=regex>&gt;</TT>.</P> <P>So far, <TT CLASS=regex>&lt;.+</TT> has matched <TT CLASS=match>&lt;EM&gt;first&lt;/EM&gt; test</TT> and the engine has arrived at the end of the string. <TT CLASS=regex>&gt;</TT> cannot match here. The engine remembers that the plus has repeated the dot more often than is required. (Remember that the plus <I>requires</I> the dot to match only once.) Rather than admitting failure, the engine will <I>backtrack</I>. It will reduce the repetition of the plus by one, and then continue trying the remainder of the regex.</P> <P>So the match of <TT CLASS=regex>.+</TT> is reduced to <TT CLASS=match>EM&gt;first&lt;/EM&gt; tes</TT>. The next token in the regex is still <TT CLASS=regex>&gt;</TT>. But now the next character in the string is the last <TT CLASS=string>t</TT>. Again, these cannot match, causing the engine to backtrack further. The total match so far is reduced to <TT CLASS=match>&lt;EM&gt;first&lt;/EM&gt; te</TT>. But <TT CLASS=regex>&gt;</TT> still cannot match. So the engine continues backtracking until the match of <TT CLASS=regex>.+</TT> is reduced to <TT CLASS=match>EM&gt;first&lt;/EM</TT>. Now, <TT CLASS=regex>&gt;</TT> can match the next character in the string. The last token in the regex has been matched. The engine reports that <TT CLASS=match>&lt;EM&gt;first&lt;/EM&gt;</TT> has been successfully matched.</P> <P>Remember that the regex engine is <I>eager</I> to return a match. It will not continue backtracking further to see if there is another possible match. It will report the first valid match it finds. Because of greediness, this is the leftmost longest match.</P> <A NAME="lazy"></A><H2>Laziness Instead of Greediness</H2> <P>The quick fix to this problem is to make the plus <i>lazy</i> instead of greedy. Lazy quantifiers are sometimes also called "ungreedy" or "reluctant". You can do that by putting a question mark behind the plus in the regex. You can do the same with the star, the curly braces and the question mark itself. So our example becomes <TT CLASS=regex>&lt;.+?&gt;</TT>. Let's have another look inside the regex engine.</P> <P>Again, <TT CLASS=regex>&lt;</TT> matches the first <TT CLASS=match>&lt;</TT> in the string. The next token is the dot, this time repeated by a lazy plus. This tells the regex engine to repeat the dot as few times as possible. The minimum is one. So the engine matches the dot with <TT CLASS=match>E</TT>. The requirement has been met, and the engine continues with <TT CLASS=regex>&gt;</TT> and <TT CLASS=string>M</TT>. This fails. Again, the engine will <I>backtrack</I>. But this time, the backtracking will force the lazy plus to expand rather than reduce its reach. So the match of <TT CLASS=regex>.+</TT> is expanded to <TT CLASS=match>EM</TT>, and the engine tries again to continue with <TT CLASS=regex>&gt;</TT>. Now, <TT CLASS=match>&gt;</TT> is matched successfully. The last token in the regex has been matched. The engine reports that <TT CLASS=match>&lt;EM&gt;</TT> has been successfully matched. That's more like it.</P> <H2>An Alternative to Laziness</H2> <P>In this case, there is a better option than making the plus lazy. We can use a greedy plus and a <A HREF="charclass.html" TARGET="_top">negated character class</A>: <TT CLASS=regex>&lt;[^&gt;]+&gt;</TT>. The reason why this is better is because of the backtracking. When using the lazy plus, the engine has to backtrack for each character in the HTML tag that it is trying to match. When using the negated character class, no backtracking occurs at all when the string contains valid HTML code. Backtracking slows down the regex engine. You will not notice the difference when doing a single search in a text editor. But you will save plenty of CPU cycles when using such a regex repeatedly in a tight loop in a script that you are writing, or perhaps in a custom syntax coloring scheme for <A HREF="editpadpro.html" TARGET="_top">EditPad Pro</A>.</P> <P>Finally, remember that this tutorial only talks about <A HREF="engine.html" TARGET="_top">regex-directed engines</A>. Text-directed engines do not backtrack. They do not get the speed penalty, but they also do not support lazy repetition operators. </P> <a name="qe"></a><H2>Repeating \Q...\E Escape Sequences</h2> <p>The <a href="characters.html#qe">\Q...\E sequence</a> escapes a string of characters, matching them as literal characters. The escaped characters are treated as individual characters. If you place a quantifier after the <tt>\E</tt>, it will only be applied to the last character. E.g. if you apply <tt class=regex>\Q*\d+*\E+</tt> to <tt class=string>*\d+**\d+*</tt>, the match will be <tt class=match>*\d+**</tt>. Only the asterisk is repeated. Java 4 and 5 have a bug that causes the whole \Q..\E sequence to be repeated, yielding the whole subject string as the match. This was fixed in Java 6.</p> <h2>Make a Donation</h2>
<p>Did this website just save you a trip to the bookstore?  Please <a href="donate.html">make a donation</a> to support this site, and you'll get a lifetime of advertisement-free access to this site!</p>
<DIV id=copyright>
<P CLASS=copyright>Page URL: <A HREF="repeat.html" TARGET="_top">http://www.Regular-Expressions.info/repeat.html</A><BR>
Page last updated: 23 October 2011<BR>
Site last updated: 17 June 2013<BR>
Copyright &copy; 2003-2013 Jan Goyvaerts. All rights reserved.</P>
</DIV> 

<script type="text/javascript"><!--
var google_conversion_id = 1072547447; var google_conversion_language = "en"; var google_conversion_format = "3"; var google_conversion_color = "666666"; var google_conversion_label = "sqPQCInO3QEQ94y3_wM"; var google_conversion_value = 0;
//-->
</script>
<script type="text/javascript" src="http://www.googleadservices.com/pagead/conversion.js"></script>
<noscript>
<div style="display:inline;">
<img height="1" width="1" style="border-style:none;" alt="" src="http://www.googleadservices.com/pagead/conversion/1072547447/?label=sqPQCInO3QEQ94y3_wM&amp;guid=ON&amp;script=0"/>
</div>
</noscript>
</DIV> 
<DIV id=side><script type="text/javascript">movecontent();</script><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tutorial</TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="tutorialcnt.html" TARGET=_top>Table&nbsp;of&nbsp;Contents</A></TD></TR><TR><TD><A HREF="characters.html" TARGET=_top>Characters</A></TD></TR><TR><TD><A HREF="engine.html" TARGET=_top>Regex&nbsp;Engine&nbsp;Internals</A></TD></TR><TR><TD><A HREF="charclass.html" TARGET=_top>Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="dot.html" TARGET=_top>Dot</A></TD></TR><TR><TD><A HREF="anchors.html" TARGET=_top>Anchors</A></TD></TR><TR><TD><A HREF="wordboundaries.html" TARGET=_top>Word&nbsp;Boundaries</A></TD></TR><TR><TD><A HREF="alternation.html" TARGET=_top>Alternation</A></TD></TR><TR><TD><A HREF="optional.html" TARGET=_top>Optional&nbsp;Items</A></TD></TR><TR><TD><A HREF="repeat.html" TARGET=_top>Repetition</A></TD></TR><TR><TD><A HREF="brackets.html" TARGET=_top>Grouping&nbsp;&amp;&nbsp;Backreferences</A></TD></TR><TR><TD><A HREF="named.html" TARGET=_top>Named&nbsp;Groups</A></TD></TR><TR><TD><A HREF="unicode.html" TARGET=_top>Unicode</A></TD></TR><TR><TD><A HREF="modifiers.html" TARGET=_top>Modifiers</A></TD></TR><TR><TD><A HREF="possessive.html" TARGET=_top>Possessive&nbsp;Quantifiers</A></TD></TR><TR><TD><A HREF="atomic.html" TARGET=_top>Atomic&nbsp;Grouping</A></TD></TR><TR><TD><A HREF="lookaround.html" TARGET=_top>Lookahead&nbsp;&amp;&nbsp;Lookbehind</A></TD></TR><TR><TD><A HREF="lookaround2.html" TARGET=_top>Lookaround,&nbsp;part&nbsp;2</A></TD></TR><TR><TD><A HREF="continue.html" TARGET=_top>Continuing&nbsp;Matches</A></TD></TR><TR><TD><A HREF="conditional.html" TARGET=_top>Conditionals</A></TD></TR><TR><TD><A HREF="xmlcharclass.html" TARGET=_top>XML&nbsp;Character&nbsp;Classes</A></TD></TR><TR><TD><A HREF="posixbrackets.html" TARGET=_top>POSIX&nbsp;Bracket&nbsp;Expressions</A></TD></TR><TR><TD><A HREF="comments.html" TARGET=_top>Comments</A></TD></TR><TR><TD><A HREF="freespacing.html" TARGET=_top>Free-Spacing</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Print&nbsp;PDF</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="updates.html" TARGET=_top>RSS&nbsp;Feed&nbsp;&amp;&nbsp;Blog</A></TD></TR></TABLE><iframe class="amazonsingle" src="http://rcm.amazon.com/e/cm?t=jgsbookselection&o=1&p=8&l=as1&asins=1449319432&md=10FE9736YVPPT7A0FBG2&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=000000&bg1=FFFFFF&f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe><P>&nbsp;</P> <TABLE CLASS=sidead CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 4</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files or folders, or scan entire drives and network shares.</TD></TR> <TR><TD CLASS=ad>Search and replace using text, binary data or one or more regular expressions to automate repetitive editing tasks. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to rename files, copy files, or merge and split the contents of files. Work with plain text files, Unicode files, binary files, compressed files, and files in proprietary formats such as MS Office, OpenOffice, and PDF. Runs on Windows 2000, XP, Vista, 7, and 8.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE></DIV><script type="text/javascript">movecontent();</script></BODY></HTML>