<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Java Demo Application using Regular Expressions</TITLE>
<script src="regex.js" type="text/javascript"></script>
<link rel="alternate" type="application/rss+xml" title="Regex Guru" href="http://www.regexguru.com/feed/">
<META NAME="Author" CONTENT="Jan Goyvaerts">
<META NAME="Description" CONTENT="Java demo application illustrating the use of the java.util.regex package that is part of the JDK 1.4.0 and later">
<META NAME="Keywords" CONTENT="">
<LINK REL=StyleSheet HREF="regex.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<script type="text/javascript">window.onresize = movecontent;</script>
<DIV id=top><DIV id=logo><IMG SRC="img/logo.gif" WIDTH=530 HEIGHT=100></DIV></DIV>
<div id=btntop><table align=center cellspacing=0 cellpadding=0 border=0><tr><td><a href="tutorial.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tutorial</div></a></td><td><a href="tools.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Tools&nbsp;&amp;&nbsp;Languages</div></a></td><td><a href="examples.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Examples</div></a></td><td><a href="books.html" target="_top"><div onmouseover="this.style.backgroundColor='#33A000';this.style.backgroundImage='url(img/btnhot.gif)';" onmouseout="this.style.backgroundColor='#A03300';this.style.backgroundImage='url(img/btn.gif)';return false;">Books&nbsp;&amp;&nbsp;Reference</div></a></td></tr></table></div>
<DIV id=bodytext>
<script type="text/javascript">movecontent();</script>
<TABLE CLASS=topad>
<TR><TD VALIGN=top><A HREF="http://www.regexbuddy.com/java.html" TARGET="_top"><IMG SRC="img/regexbuddyad.png" width=203 height=145 ALT="RegexBuddy" BORDER=0></A></TD>
<TD CLASS=topad><B><A HREF="http://www.regexbuddy.com/java.html" TARGET="_top">Easily use the power of regular expressions in your Java applications</A> with RegexBuddy.</B><BR>
Create and analyze regex patterns with RegexBuddy's intuitive regex building blocks.  Implement regexes in your applications with instant Java code snippets.  Just tell RegexBuddy what you want to achieve, and copy and paste the auto-generated Java code. <A HREF="http://www.regexbuddy.com/">Get your own copy of RegexBuddy now</A>.</TD></TR></TABLE>


<H1>Java Demo Application using Regular Expressions</H1>



<P><A HREF="java.html" TARGET="_top">Learn how to use the java.util.regex package</A>.</P>
<P><A HREF="http://www.regular-expressions.info/download/javaregexdemo.zip">Download the demo application and complete source code</A></P>



<PRE><SPAN CLASS="longcode"><SPAN CLASS="reservedword">package</SPAN> regexdemo;

<SPAN CLASS="reservedword">import</SPAN> java.util.regex.*;

<SPAN CLASS="reservedword">import</SPAN> java.awt.*;
<SPAN CLASS="reservedword">import</SPAN> java.awt.event.*;
<SPAN CLASS="reservedword">import</SPAN> javax.swing.*;

<SPAN CLASS="comment">/**
 * Regular Expressions Demo
 * Demonstration showing how to use the java.util.regex package that is part of 
 * the JDK 1.4 and later
 * Copyright (c) 2003 Jan Goyvaerts.  All rights reserved.
 * Visit http://www.regular-expressions.info for a detailed tutorial 
 * to regular expressions.
 * This source code is provided for educational purposes only, without any warranty of any kind.
 * Distribution of this source code and/or the application compiled 
 * from this source code is prohibited.
 * Please refer everybody interested in getting a copy of the source code to
 * http://www.regular-expressions.info
 * @author Jan Goyvaerts
 * @version 1.0
 */</SPAN>

<SPAN CLASS="reservedword">public class</SPAN> FrameRegexDemo <SPAN CLASS="reservedword">extends</SPAN> JFrame {

  <SPAN CLASS="comment">// Code generated by the JBuilder 9 designer to create the frame depicted below
  // has been omitted for brevity</SPAN>

  <IMG SRC="screens/javaexample.png" ALT="Java Demo Application using Regular Expressions">

  <SPAN CLASS="comment">/** The easiest way to check if a particular string matches a regular expression
   *  is to simply call String.matches() passing the regular expression to it.
   *  It is not possible to set matching options this way, so the checkboxes
   *  in this demo are ignored when clicking btnMatch.&lt;p&gt;
   *
   *  One disadvantage of this method is that it will only return true if 
   *  the regex matches the *entire* string.  In other words, an implicit \A 
   *  is prepended to the regex and an implicit \z is appended to it.
   *  So you cannot use matches() to test if a substring anywhere in the string
   *  matches the regex.&lt;p&gt;
   *
   *  Note that when typing in a regular expression into textSubject,
   *  backslashes are interpreted at the regex level.
   *  Typing in \( will match a literal ( and \\ matches a literal backslash.
   *  When passing literal strings in your source code, you need to escape
   *  backslashes in strings as usual.
   *  The string "\\(" matches a literal ( character
   *  and "\\\\" matches a single literal backslash.
   */</SPAN>
  <SPAN CLASS="reservedword">void</SPAN> btnMatch_actionPerformed(ActionEvent e) {
    textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
    <SPAN CLASS="comment">// Calling the Pattern.matches static method is an alternative way
    // if (Pattern.matches(textRegex.getText(), textSubject.getText())) {</SPAN>
    <SPAN CLASS="reservedword">try</SPAN>&nbsp;{
      <SPAN CLASS="reservedword">if</SPAN> (textSubject.getText().matches(textRegex.getText())) {
        textResults.setText(<SPAN CLASS="characterstring">"The regex matches the entire subject"</SPAN>);
      }
      <SPAN CLASS="reservedword">else</SPAN>&nbsp;{
        textResults.setText(<SPAN CLASS="characterstring">"The regex does not match the entire subject"</SPAN>);
      }
    }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (PatternSyntaxException ex) {
      textResults.setText(<SPAN CLASS="characterstring">"You have an error in your regular expression:\n"</SPAN> +
                          ex.getDescription());
    }
  }

  <SPAN CLASS="comment">/** The easiest way to perform a regex search-and-replace on a string
   *  is to call the string's replaceFirst() and replaceAll() methods.
   *  replaceAll() will replace all substrings that match the regular expression
   *  with the replacement string, while replaceFirst() will only replace 
   *  the first match.&lt;p&gt;
   *
   *  Again, you cannot set matching options this way, so the checkboxes
   *  in this demo are ignored when clicking btnMatch.&lt;p&gt;
   *
   *  In the replacement text, you can use $0 to insert the entire regex match,
   *  and $1, $2, $3, etc. for the backreferences (text matched by the part in the
   *  regex between the first, second, third, etc. pair of round brackets)&lt;br&gt;
   *  \$ inserts a single $ character.&lt;p&gt;
   *
   *  $$ or other improper use of the $ sign throws an IllegalArgumentException.
   *  If you reference a group that does not exist (e.g. $4 if there are only
   *  3 groups), throws an IndexOutOfBoundsException.
   *  Be sure to properly handle these exceptions if you allow the end user 
   *  to type in the replacement text.&lt;p&gt;
   *
   *  Note that in the memo control, you type \$ to insert a dollar sign,
   *  and \\ to insert a backslash.  If you provide the replacement string as a
   *  string literal in your Java code, you need to use "\\$" and "\\\\".
   *  This is because backslashes need to be escaped in Java string literals too.
   */</SPAN>
  <SPAN CLASS="reservedword">void</SPAN> btnReplace_actionPerformed(ActionEvent e) {
    <SPAN CLASS="reservedword">try</SPAN>&nbsp;{
      textReplaceResults.setText(
        textSubject.getText().replaceAll(
          textRegex.getText(), textReplace.getText())
      );
      textResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
    }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (PatternSyntaxException ex) {
      <SPAN CLASS="comment">// textRegex does not contain a valid regular expression</SPAN>
      textResults.setText(<SPAN CLASS="characterstring">"You have an error in your regular expression:\n"</SPAN> +
                          ex.getDescription());
      textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
    }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (IllegalArgumentException ex) {
      <SPAN CLASS="comment">// textReplace contains inapropriate dollar signs</SPAN>
      textResults.setText(<SPAN CLASS="characterstring">"You have an error in the replacement text:\n"</SPAN> +
                          ex.getMessage());
      textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
    }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (IndexOutOfBoundsException ex) {
      <SPAN CLASS="comment">// textReplace contains a backreference that does not exist
      // (e.g. $4 if there are only three groups)</SPAN>
      textResults.setText(<SPAN CLASS="characterstring">"Non-existent group in the replacement text:\n"</SPAN> +
                          ex.getMessage());
      textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
    }
  }

  <SPAN CLASS="comment">/** Show the results of splitting a string. */</SPAN>
  <SPAN CLASS="reservedword">void</SPAN> printSplitArray(String[] array) {
    textResults.setText(<SPAN CLASS="reservedword">null</SPAN>);
    <SPAN CLASS="reservedword">for</SPAN> (<SPAN CLASS="reservedword">int</SPAN> i = <SPAN CLASS="numericconstant">0</SPAN>; i &lt; array.length; i++) {
      textResults.append(Integer.toString(i) + <SPAN CLASS="characterstring">": \""</SPAN> + array[i] + <SPAN CLASS="characterstring">"\"\r\n"</SPAN>);
    }
  }

  <SPAN CLASS="comment">/** The easiest way to split a string into an array of strings is by calling
   *  the string's split() method.  The string will be split at each substring
   *  that matches the regular expression.  The regex matches themselves are
   *  thrown away.&lt;p&gt;
   *
   *  If the split would result in trailing empty strings, (when the regex matches
   *  at the end of the string), the trailing empty strings are also thrown away.
   *  If you want to keep the empty strings, call split(regex, -1).  The -1 tells
   *  the split() method to add trailing empty strings to the resulting array.&lt;p&gt;
   *
   *  You can limit the number of items in the resulting array by specifying a
   *  positive number as the second parameter to split().  The limit you specify
   *  it the number of items the array will at most contain.  The regex is applied
   *  at most limit-1 times, and the last item in the array contains the unsplit
   *  remainder of the original string.  If you are only interested in the first
   *  3 items in the array, specify a limit of 4 and disregard the last item.
   *  This is more efficient than having the string split completely.
   */</SPAN>
  <SPAN CLASS="reservedword">void</SPAN> btnSplit_actionPerformed(ActionEvent e) {
    textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
    <SPAN CLASS="reservedword">try</SPAN>&nbsp;{
      printSplitArray(textSubject.getText().split(textRegex.getText() 
                                                  <SPAN CLASS="comment">/*, Limit*/</SPAN> ));
    }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (PatternSyntaxException ex) {
      <SPAN CLASS="comment">// textRegex does not contain a valid regular expression</SPAN>
      textResults.setText(<SPAN CLASS="characterstring">"You have an error in your regular expression:\n"</SPAN> +
                          ex.getDescription());
    }
  }

  <SPAN CLASS="comment">/** Figure out the regex options to be passed to the Pattern.compile()
   *  class factory based on the state of the checkboxes.
   */</SPAN>
  <SPAN CLASS="reservedword">int</SPAN> getRegexOptions() {
    <SPAN CLASS="reservedword">int</SPAN> Options = <SPAN CLASS="numericconstant">0</SPAN>;
    <SPAN CLASS="reservedword">if</SPAN> (checkCanonEquivalence.isSelected()) {
      <SPAN CLASS="comment">// In Unicode, certain characters can be encoded in more than one way.
      // Many letters with diacritics can be encoded as a single character
      // identifying the letter with the diacritic, and encoded as two
      // characters: the letter by itself followed by the diacritic by itself
      // Though the internal representation is different, when the string is
      // rendered to the screen, the result is exactly the same.</SPAN>
      Options |= Pattern.CANON_EQ;
    }
    <SPAN CLASS="reservedword">if</SPAN> (checkCaseInsensitive.isSelected()) {
      <SPAN CLASS="comment">// Omitting UNICODE_CASE causes only US ASCII characters to be matched
      // case insensitively.  This is appropriate if you know beforehand that 
      // the subject string will only contain US ASCII characters
      // as it speeds up the pattern matching.</SPAN>
      Options |= Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
    }
    <SPAN CLASS="reservedword">if</SPAN> (checkDotAll.isSelected()) {
      <SPAN CLASS="comment">// By default, the dot will not match line break characters.
      // Specify this option to make the dot match all characters, 
      // including line breaks</SPAN>
      Options |= Pattern.DOTALL;
    }
    <SPAN CLASS="reservedword">if</SPAN> (checkMultiLine.isSelected()) {
      <SPAN CLASS="comment">// By default, the caret ^, dollar $  only match at the start 
      // and the end of the string.  Specify this option to make ^ also match 
      // after line breaks in the string, and make $ match before line breaks.</SPAN>
      Options |= Pattern.MULTILINE;
    }
    <SPAN CLASS="reservedword">return</SPAN> Options;
  }

  <SPAN CLASS="comment">/** Pattern constructed by btnObject */</SPAN>
  Pattern compiledRegex;

  <SPAN CLASS="comment">/** Matcher object that will search the subject string using compiledRegex */</SPAN>
  Matcher regexMatcher;
  JLabel jLabel8 = <SPAN CLASS="reservedword">new</SPAN> JLabel();
  JButton btnAdvancedReplace = <SPAN CLASS="reservedword">new</SPAN> JButton();

  <SPAN CLASS="comment">/** If you will be using a particular regular expression often,
   *  you should create a Pattern object to store the regular expression.
   *  You can then reuse the regex as often as you want by reusing the
   *  Pattern object.&lt;p&gt;
   *
   *  To use the regular expression on a string, create a Matcher object
   *  by calling compiledRegex.matcher() passing the subject string to it.
   *  The Matcher will do the actual searching, replacing or splitting.&lt;p&gt;
   *
   *  You can create as many Matcher objects from a single Pattern object
   *  as you want, and use the Matchers at the same time.  To apply the regex
   *  to another subject string, either create a new Matcher using
   *  compiledRegex.matcher() or tell the existing Matcher to work on a new
   *  string by calling regexMatcher.reset(subjectString).
   */</SPAN>
  <SPAN CLASS="reservedword">void</SPAN> btnObjects_actionPerformed(ActionEvent e) {
    compiledRegex = <SPAN CLASS="reservedword">null</SPAN>;
    textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
    <SPAN CLASS="reservedword">try</SPAN>&nbsp;{
      <SPAN CLASS="comment">// If you do not want to specify any options (this is the case when
      // all checkboxes in this demo are unchecked), you can omit the
      // second parameter for the Pattern.compile() class factory.</SPAN>
      compiledRegex = Pattern.compile(textRegex.getText(), getRegexOptions());
      <SPAN CLASS="comment">// Create the object that will search the subject string
      // using the regular expression.</SPAN>
      regexMatcher = compiledRegex.matcher(textSubject.getText());
      textResults.setText(<SPAN CLASS="characterstring">"Pattern and Matcher objects created."</SPAN>);
    }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (PatternSyntaxException ex) {
      <SPAN CLASS="comment">// textRegex does not contain a valid regular expression</SPAN>
      textResults.setText(<SPAN CLASS="characterstring">"You have an error in your regular expression:\n"</SPAN> +
                          ex.getDescription());
    }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (IllegalArgumentException ex) {
      <SPAN CLASS="comment">// This exception indicates a bug in getRegexOptions</SPAN>
      textResults.setText(<SPAN CLASS="characterstring">"Undefined bit values are set in the regex options"</SPAN>);
    }
  }

  <SPAN CLASS="comment">/** Print the results of a search produced by regexMatcher.find()
   *  and stored in regexMatcher.
   */</SPAN>
  <SPAN CLASS="reservedword">void</SPAN> printMatch() {
    <SPAN CLASS="reservedword">try</SPAN>&nbsp;{
      textResults.setText(<SPAN CLASS="characterstring">"Index of the first character in the match: "</SPAN> +
                          Integer.toString(regexMatcher.start()) + <SPAN CLASS="characterstring">"\n"</SPAN>);
      textResults.append(<SPAN CLASS="characterstring">"Index of the first character after the match: "</SPAN> +
                         Integer.toString(regexMatcher.end()) + <SPAN CLASS="characterstring">"\n"</SPAN>);
      textResults.append(<SPAN CLASS="characterstring">"Length of the match: "</SPAN> +
                         Integer.toString(regexMatcher.end() - 
                                          regexMatcher.start()) + <SPAN CLASS="characterstring">"\n"</SPAN>);
      textResults.append(<SPAN CLASS="characterstring">"Matched text: "</SPAN> + regexMatcher.group() + <SPAN CLASS="characterstring">"\n"</SPAN>);
      <SPAN CLASS="reservedword">if</SPAN> (regexMatcher.groupCount() &gt; <SPAN CLASS="numericconstant">0</SPAN>) {
        <SPAN CLASS="comment">// Capturing parentheses are numbered 1..groupCount()
        // group number zero is the entire regex match</SPAN>
        <SPAN CLASS="reservedword">for</SPAN> (<SPAN CLASS="reservedword">int</SPAN> i = <SPAN CLASS="numericconstant">1</SPAN>; i &lt;= regexMatcher.groupCount(); i++) {
          String groupLabel = <SPAN CLASS="reservedword">new</SPAN> String(<SPAN CLASS="characterstring">"Group "</SPAN> + Integer.toString(i));
          <SPAN CLASS="reservedword">if</SPAN> (regexMatcher.start(i) &lt; <SPAN CLASS="numericconstant">0</SPAN>) {
            textResults.append(groupLabel + <SPAN CLASS="characterstring">
                               " did not participate in the overall match\n"</SPAN>);
          }&nbsp;<SPAN CLASS="reservedword">else</SPAN>&nbsp;{
            textResults.append(groupLabel + <SPAN CLASS="characterstring">" start: "</SPAN> +
                               Integer.toString(regexMatcher.start(i)) + <SPAN CLASS="characterstring">"\n"</SPAN>);
            textResults.append(groupLabel + <SPAN CLASS="characterstring">" end: "</SPAN> +
                               Integer.toString(regexMatcher.end(i)) + <SPAN CLASS="characterstring">"\n"</SPAN>);
            textResults.append(groupLabel + <SPAN CLASS="characterstring">" length: "</SPAN> +
                               Integer.toString(regexMatcher.end(i) -
                                                regexMatcher.start(i)) + <SPAN CLASS="characterstring">"\n"</SPAN>);
            textResults.append(groupLabel + <SPAN CLASS="characterstring">" matched text: "</SPAN> + 
                               regexMatcher.group(i) + <SPAN CLASS="characterstring">"\n"</SPAN>);
          }
        }
      }
    }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (IllegalStateException ex) {
      <SPAN CLASS="comment">// Querying the results of a Matcher object before calling find()
      // or after a call to find() returned False, throws an IllegalStateException
      // This indicates a bug in our application</SPAN>
      textResults.setText(<SPAN CLASS="characterstring">"Cannot print match results if there aren't any"</SPAN>);
    }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (IndexOutOfBoundsException ex) {
      <SPAN CLASS="comment">// Querying the results of groups (capturing parentheses or backreferences)
      // that do not exist throws an IndexOutOfBoundsException
      // This indicates a bug in our application</SPAN>
      textResults.setText(<SPAN CLASS="characterstring">"Cannot print match results of non-existent groups"</SPAN>);
    }
  }

  <SPAN CLASS="comment">/** Finds the first match if this is the first search, or if the previous search
   *  came up empty. Otherwise, it finds the next match after the previous match.
   *
   *  Note that even if you typed in new text for the regex or subject,
   *  btnNextMatch uses the subject and regex as they were when you clicked
   *  btnCreateObjects.
   */</SPAN>
  <SPAN CLASS="reservedword">void</SPAN> btnNextMatch_actionPerformed(ActionEvent e) {
    textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
    <SPAN CLASS="reservedword">if</SPAN> (regexMatcher == <SPAN CLASS="reservedword">null</SPAN>) {
      textResults.setText(<SPAN CLASS="characterstring">"Click Create Objects to create the Matcher object"</SPAN>);
    }&nbsp;<SPAN CLASS="reservedword">else</SPAN>&nbsp;{
      <SPAN CLASS="comment">// Caling Matcher.find() without any parameters continues the search at
      // Matcher.end().  Starts from the beginning of the string if this is 
      // the first search using the Matcher or if the previous search 
      // did not find any (further) matches.</SPAN>
      <SPAN CLASS="reservedword">if</SPAN> (regexMatcher.find()) {
        printMatch();
      }&nbsp;<SPAN CLASS="reservedword">else</SPAN>&nbsp;{
        <SPAN CLASS="comment">// This also resets the starting position for find() 
        // to the start of the subject string</SPAN>
        textResults.setText(<SPAN CLASS="characterstring">"No further matches"</SPAN>);
      }
    }
  }

  <SPAN CLASS="comment">/** Perform a regular expression search-and-replace using a Matcher object.
   *  This is the recommended way if you often use the same regular expression
   *  to do a search-and-replace.  You should also reuse the Matcher object
   *  by calling Matcher.reset(nextSubjectString) for improved efficiency.&lt;p&gt;
   *
   *  You also need to use the Pattern and Matcher objects for the 
   *  search-and-replace if you want to use the regex options such as 
   *  "case insensitive" or "dot all".&lt;p&gt;
   *
   *  See the btnReplace notes for the special $-syntax in the replacement text.
   */</SPAN>
  <SPAN CLASS="reservedword">void</SPAN> btnObjReplace_actionPerformed(ActionEvent e) {
    <SPAN CLASS="reservedword">if</SPAN> (regexMatcher == <SPAN CLASS="reservedword">null</SPAN>) {
      textResults.setText(<SPAN CLASS="characterstring">"Click Create Objects to create the Matcher object"</SPAN>);
    }&nbsp;<SPAN CLASS="reservedword">else</SPAN>&nbsp;{
      <SPAN CLASS="reservedword">try</SPAN>&nbsp;{
        textReplaceResults.setText(regexMatcher.replaceAll(textReplace.getText()));
      }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (IllegalArgumentException ex) {
        <SPAN CLASS="comment">// textReplace contains inapropriate dollar signs</SPAN>
        textResults.setText(<SPAN CLASS="characterstring">"You have an error in the replacement text:\n"</SPAN> +
                            ex.getMessage());
        textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
      }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (IndexOutOfBoundsException ex) {
        <SPAN CLASS="comment">// textReplace contains a backreference that does not exist
        // (e.g. $4 if there are only three groups)</SPAN>
        textResults.setText(<SPAN CLASS="characterstring">"Non-existent group in the replacement text:\n"</SPAN> +
                            ex.getMessage());
        textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
      }
    }
  }

  <SPAN CLASS="comment">/** Using Matcher.appendReplacement() and Matcher.appendTail() you can implement
   *  a search-and-replace of arbitrary complexity.  These routines allow you
   *  to compute the replacement string in your own code.  So the replacement text
   *  can be whatever you want.&lt;p&gt;
   *
   *  To do this, simply call Matcher.find() in a loop.  For each match returned
   *  by find(), call appendReplacement() with whatever replacement text you want.
   *  When find() can no longer find matches, call appendTail().&lt;p&gt;
   *
   *  appendReplacement() appends the substring between the end of the previous
   *  match that was replaced with appendReplacement() and the current match.  
   *  If this is the first call to appendReplacement() since creating the Matcher
   *  or calling reset(), then the appended substring starts at the start of 
   *  the string.  Then, the specified replacement text is appended.  
   *  If the replacement text contains dollar signs, they will be interpreted 
   *  as usual.  E.g. $1 is replaced with the match between the first pair of 
   *  capturing parentheses.&lt;p&gt;
   *
   *  appendTail() appends the substring between the end of the previous match
   *  that was replaceced with appendReplacement() and the end of the string.
   *  If appendReplacement() was not called since creating the Matcher or 
   *  calling reset(), the entire subject string is appended.&lt;p&gt;
   *
   *  The above means that you should call Matcher.reset() before starting the
   *  operation, unless you're sure the Matcher is freshly constructed.
   *  If certain matches do not need to be replaced, simply skip calling 
   *  appendReplacement() for those matches. (Calling appendReplacement() with 
   *  Matcher.group() as the replacement text will only hurt performance and 
   *  may get you into trouble with dollar signs that may appear in the match.)
   */</SPAN>
  <SPAN CLASS="reservedword">void</SPAN> btnAdvancedReplace_actionPerformed(ActionEvent e) {
    <SPAN CLASS="reservedword">if</SPAN> (regexMatcher == <SPAN CLASS="reservedword">null</SPAN>) {
      textResults.setText(<SPAN CLASS="characterstring">"Click Create Objects to create the Matcher object"</SPAN>);
    }&nbsp;<SPAN CLASS="reservedword">else</SPAN>&nbsp;{
      <SPAN CLASS="comment">// We will store the replacement text here</SPAN>
      StringBuffer replaceResult = <SPAN CLASS="reservedword">new</SPAN> StringBuffer();
      <SPAN CLASS="reservedword">while</SPAN> (regexMatcher.find()) {
        <SPAN CLASS="reservedword">try</SPAN>&nbsp;{
          <SPAN CLASS="comment">// In this example, we simply replace the regex match with the same text
          // in uppercase.  Note that appendReplacement parses the replacement 
          // text to substitute $1, $2, etc. with the contents of the 
          // corresponding capturing parentheses just like replaceAll()</SPAN>
          regexMatcher.appendReplacement(replaceResult, 
                                         regexMatcher.group().toUpperCase());
        }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (IllegalStateException ex) {
          <SPAN CLASS="comment">// appendReplacement() was called without a prior successful call to find()
          // This exception indicates a bug in your source code</SPAN>
          textResults.setText(<SPAN CLASS="characterstring">"appendReplacement() called without a prior"</SPAN> +
                              <SPAN CLASS="characterstring">"successful call to find()"</SPAN>);
          textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
          <SPAN CLASS="reservedword">return</SPAN>;
        }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (IllegalArgumentException ex) {
          <SPAN CLASS="comment">// Replacement text contains inapropriate dollar signs</SPAN>
          textResults.setText(<SPAN CLASS="characterstring">"Error in the replacement text:\n"</SPAN> +
                              ex.getMessage());
          textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
          <SPAN CLASS="reservedword">return</SPAN>;
        }&nbsp;<SPAN CLASS="reservedword">catch</SPAN> (IndexOutOfBoundsException ex) {
          <SPAN CLASS="comment">// Replacement text contains a backreference that does not exist
          // (e.g. $4 if there are only three groups)</SPAN>
          textResults.setText(<SPAN CLASS="characterstring">"Non-existent group in the replacement text:\n"</SPAN> +
                              ex.getMessage());
          textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
          <SPAN CLASS="reservedword">return</SPAN>;
        }
      }
      regexMatcher.appendTail(replaceResult);
      textReplaceResults.setText(replaceResult.toString());
      textResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
      <SPAN CLASS="comment">// After using appendReplacement and appendTail, the Matcher object must be 
      // reset so we can use appendReplacement and appendTail again.
      // In practice, you will probably put this call at the start of the routine
      // where you want to use appendReplacement and appendTail.
      // I did not do that here because this way you can click on the Next Match
      // button a couple of times to skip a few matches, and then click on the
      // Advanced Replace button to observe that appendReplace() will copy the
      // skipped matches unchanged.</SPAN>
      regexMatcher.reset();
    }
  }

  <SPAN CLASS="comment">/** If you want to split many strings using the same regular expression,
   *  you should create a Pattern object and call Pattern.split()
   *  rather than String.split().  Both methods produce exactly the same results.
   *  However, when creating a Pattern object, you can specify options such as
   *  "case insensitive" and "dot all".&lt;p&gt;
   *
   *  Note that no Matcher object is used.
   */</SPAN>
  <SPAN CLASS="reservedword">void</SPAN> btnObjSplit_actionPerformed(ActionEvent e) {
    textReplaceResults.setText(<SPAN CLASS="characterstring">"n/a"</SPAN>);
    <SPAN CLASS="reservedword">if</SPAN> (compiledRegex == <SPAN CLASS="reservedword">null</SPAN>) {
      textResults.setText(<SPAN CLASS="characterstring">"Please click Create Objects to compile the regex"</SPAN>);
    }&nbsp;<SPAN CLASS="reservedword">else</SPAN>&nbsp;{
      printSplitArray(compiledRegex.split(textSubject.getText() <SPAN CLASS="comment">/*, Limit*/</SPAN>));
    }
  }
}

<SPAN CLASS="comment">// ActionListener classes generated by JBuilder 9 have been omitted for brevity</SPAN>
</SPAN></PRE>
<script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><h2>Make a Donation</h2>
<p>Did this website just save you a trip to the bookstore?  Please <a href="donate.html">make a donation</a> to support this site, and you'll get a lifetime of advertisement-free access to this site!</p>
<DIV id=copyright>
<P CLASS=copyright>Page URL: <A HREF="javaexample.html" TARGET="_top">http://www.Regular-Expressions.info/javaexample.html</A><BR>
Page last updated: 22 September 2010<BR>
Site last updated: 17 June 2013<BR>
Copyright &copy; 2003-2013 Jan Goyvaerts. All rights reserved.</P>
</DIV> 

<script type="text/javascript"><!--
var google_conversion_id = 1072547447; var google_conversion_language = "en"; var google_conversion_format = "3"; var google_conversion_color = "666666"; var google_conversion_label = "sqPQCInO3QEQ94y3_wM"; var google_conversion_value = 0;
//-->
</script>
<script type="text/javascript" src="http://www.googleadservices.com/pagead/conversion.js"></script>
<noscript>
<div style="display:inline;">
<img height="1" width="1" style="border-style:none;" alt="" src="http://www.googleadservices.com/pagead/conversion/1072547447/?label=sqPQCInO3QEQ94y3_wM&amp;guid=ON&amp;script=0"/>
</div>
</noscript>
</DIV> 
<DIV id=side><script type="text/javascript">movecontent();</script><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Regex Tools</TD></TR><TR><TD><A HREF="grep.html" TARGET=_top>grep</A></TD></TR><TR><TD><A HREF="powergrep.html" TARGET=_top>PowerGREP</A></TD></TR><TR><TD><A HREF="regexbuddy.html" TARGET=_top>RegexBuddy</A></TD></TR><TR><TD><A HREF="regexmagic.html" TARGET=_top>RegexMagic</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>General Applications</TD></TR><TR><TD><A HREF="editpadpro.html" TARGET=_top>EditPad&nbsp;Pro</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Languages &amp; Libraries</TD></TR><TR><TD><A HREF="delphi.html" TARGET=_top>Delphi</A></TD></TR><TR><TD><A HREF="gnu.html" TARGET=_top>GNU&nbsp;(Linux)</A></TD></TR><TR><TD><A HREF="groovy.html" TARGET=_top>Groovy</A></TD></TR><TR><TD><A HREF="java.html" TARGET=_top>Java</A></TD></TR><TR><TD><A HREF="javascript.html" TARGET=_top>JavaScript</A></TD></TR><TR><TD><A HREF="dotnet.html" TARGET=_top>.NET</A></TD></TR><TR><TD><A HREF="pcre.html" TARGET=_top>PCRE&nbsp;(C/C++)</A></TD></TR><TR><TD><A HREF="perl.html" TARGET=_top>Perl</A></TD></TR><TR><TD><A HREF="php.html" TARGET=_top>PHP</A></TD></TR><TR><TD><A HREF="posix.html" TARGET=_top>POSIX</A></TD></TR><TR><TD><A HREF="powershell.html" TARGET=_top>PowerShell</A></TD></TR><TR><TD><A HREF="python.html" TARGET=_top>Python</A></TD></TR><TR><TD><A HREF="rlanguage.html" TARGET=_top>R</A></TD></TR><TR><TD><A HREF="realbasic.html" TARGET=_top>REALbasic</A></TD></TR><TR><TD><A HREF="ruby.html" TARGET=_top>Ruby</A></TD></TR><TR><TD><A HREF="tcl.html" TARGET=_top>Tcl</A></TD></TR><TR><TD><A HREF="vbscript.html" TARGET=_top>VBScript</A></TD></TR><TR><TD><A HREF="vb.html" TARGET=_top>Visual&nbsp;Basic&nbsp;6</A></TD></TR><TR><TD><A HREF="wxwidgets.html" TARGET=_top>wxWidgets</A></TD></TR><TR><TD><A HREF="xml.html" TARGET=_top>XML&nbsp;Schema</A></TD></TR><TR><TD><A HREF="xpath.html" TARGET=_top>XQuery&nbsp;&amp;&nbsp;XPath</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>Databases</TD></TR><TR><TD><A HREF="mysql.html" TARGET=_top>MySQL</A></TD></TR><TR><TD><A HREF="oracle.html" TARGET=_top>Oracle</A></TD></TR><TR><TD><A HREF="postgresql.html" TARGET=_top>PostgreSQL</A></TD></TR>
</TABLE><TABLE CLASS=side CELLSPACING=0 CELLPADDING=4><TR><TD CLASS=sideheader>More Information</TD></TR><TR><TD><A HREF="index.html" TARGET=_top>Introduction</A></TD></TR><TR><TD><A HREF="quickstart.html" TARGET=_top>Quick&nbsp;Start</A></TD></TR><TR><TD><A HREF="tutorial.html" TARGET=_top>Tutorial</A></TD></TR><TR><TD><A HREF="tools.html" TARGET=_top>Tools&nbsp;and&nbsp;Languages</A></TD></TR><TR><TD><A HREF="examples.html" TARGET=_top>Examples</A></TD></TR><TR><TD><A HREF="books.html" TARGET=_top>Books</A></TD></TR><TR><TD><A HREF="reference.html" TARGET=_top>Reference</A></TD></TR><TR><TD><A HREF="print.html" TARGET=_top>Print&nbsp;PDF</A></TD></TR><TR><TD><A HREF="about.html" TARGET=_top>About&nbsp;This&nbsp;Site</A></TD></TR><TR><TD><A HREF="updates.html" TARGET=_top>RSS&nbsp;Feed&nbsp;&amp;&nbsp;Blog</A></TD></TR></TABLE><iframe class="amazonsingle" src="http://rcm.amazon.com/e/cm?t=jgsbookselection&o=1&p=8&l=as1&asins=1449319432&md=10FE9736YVPPT7A0FBG2&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=000000&bg1=FFFFFF&f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe><iframe class="amazonsingle" src="http://rcm.amazon.com/e/cm?t=jgsbookselection&o=1&p=8&l=as1&asins=1590591070&fc1=000000&lc1=0000ff&bc1=000000&lt1=_blank&nou=1&IS2=1&bg1=ffffff&f=ifr" width="120" height="240" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe> <br> <iframe class="amazon" marginwidth="0" marginheight="0" width="160" height="600" scrolling="no" frameborder="0" src="http://rcm.amazon.com/e/cm?t=jgsbookselection&l=st1&search=Java&mode=books&p=14&o=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&lt1=_blank&nou&f=ifr"></iframe><P>&nbsp;</P> <TABLE CLASS=sidead CELLSPACING=0 CELLPADDING=4> <TR><TD CLASS=sideheader>PowerGREP 4</TD></TR> <TR><TD CLASS=ad><A HREF="http://www.powergrep.com/" TARGET=_top><IMG SRC="img/pgr.gif" WIDTH=32 HEIGHT=32 ALT="PowerGREP" ALIGN=LEFT CLASS=iconleft BORDER=0></A> <A HREF="http://www.powergrep.com/" TARGET=_top>PowerGREP</A> is probably the most powerful regex-based text processing tool available today. A knowledge worker's Swiss army knife for searching through, extracting information from, and updating piles of files.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to search through large numbers of text and binary files. Quickly find the files you are looking for, or extract the information you need. Look through just a handful of files or folders, or scan entire drives and network shares.</TD></TR> <TR><TD CLASS=ad>Search and replace using text, binary data or one or more regular expressions to automate repetitive editing tasks. Preview replacements before modifying files, and stay safe with flexible backup and undo options.</TD></TR> <TR><TD CLASS=ad>Use regular expressions to rename files, copy files, or merge and split the contents of files. Work with plain text files, Unicode files, binary files, compressed files, and files in proprietary formats such as MS Office, OpenOffice, and PDF. Runs on Windows 2000, XP, Vista, 7, and 8.</TD></TR> <TR><TD><A HREF="http://www.powergrep.com/" TARGET=_top>More information</A></TD></TR> <TR><TD><A HREF="http://www.powergrep.com/download.html" TARGET=_top>Download PowerGREP now</A></TD></TR> </TABLE><div>
<script type="text/javascript"><!--
google_ad_client = "pub-7485249680256358";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "FF6600";
google_color_bg = "FFF4E8";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "803300";
google_ui_features = "rc:0";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div></DIV><script type="text/javascript">movecontent();</script></BODY></HTML>